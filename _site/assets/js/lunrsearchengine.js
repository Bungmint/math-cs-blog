
var documents = [{
    "id": 0,
    "url": "http://localhost:4000/math-cs-blog/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "http://localhost:4000/math-cs-blog/about",
    "title": "About Me",
    "body": "Hello! Welcome to my blog. I am Youngmin Park, a math and cs majorat University of California, Berkeley. I usually go by the username Bungmint on many websites. This blogis a project of mine to jot down notes about anything mathematics/CS related (mainly about competitive programming);Here are some of my profiles on comeptitive programming websites:  Codeforces Atcoder dmojThis blog idea is deeply inspired by smax’s blog, so check his blog out, too!Also, this website is powered by Jekyll and uses the “Mediumish” theme. "
    }, {
    "id": 2,
    "url": "http://localhost:4000/math-cs-blog/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "http://localhost:4000/math-cs-blog/",
    "title": "Home",
    "body": "   Featured:                                                                                 First Post               :                Hello! I am Youngmin Park, a first-year math &amp; compsci major at UC Berkeley. I decided to make a blog to become a more organized. . .        :                                     05 Jan 2023        &lt;/span&gt;                                                             All Posts:                                                     April Problem-solving              :       JOISC 2018/2019. Cake 3:                               11 Apr 2024        &lt;/span&gt;                                                                             February Problem Solving              :       CodeForces 1922F. Replace on Segment:                               11 Feb 2024        &lt;/span&gt;                                                                             January Problem Solving              :       Spotify Challenge 2010. Apparatus:                               09 Jan 2024        &lt;/span&gt;                                                                             CodeForces Pinely Round 3              :       I am very happy with my performance in the round despite not participating for nearly 6 months. Back to IM!:                               23 Dec 2023        &lt;/span&gt;                                                                             February Problem-solving              :       CSES Counting Tiles:                               25 Feb 2023        &lt;/span&gt;                                                                             Aho-Corasick and Applications              :       Prerequisites: Aho-Corasick:                               15 Jan 2023        &lt;/span&gt;                                     &laquo; Prev       1        2      Next &raquo;  "
    }, {
    "id": 4,
    "url": "http://localhost:4000/math-cs-blog/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "http://localhost:4000/math-cs-blog/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}    Featured:     {% for post in site. posts %} {% if post. featured == true %} {% include  featuredbox. html %} {% endif %} {% endfor %} {% endif %}    All Posts:     {% for post in paginator. posts %} {% include postbox. html %} {% endfor %}     {% include pagination. html %} "
    }, {
    "id": 6,
    "url": "http://localhost:4000/math-cs-blog/April-problem-solving/",
    "title": "April Problem-solving",
    "body": "2024/04/11 - JOISC 2018/2019. Cake 3: First, note that for a fixed set of cakes, it is optimal to place them in an increasing order of the cost to minimize the cost penalty. Then, suppose $f(i, j)$ denote the maximum beauty of the cake given that all the cakes are chosen from $[i, j]$ and the cost incurred is $-2(C_j - C_i)$. Let $opt(i)$ be the optimum maximizing $opt(i, j)$ for $i$. It is easy to prove that $opt(i) \leq opt(i + 1)$. Thus, we can use divide and conquer optimization, and for computing the top $m$ value sum of an interval, we could use persistent segment tree or simply noting that we can use $O(optr - optl + r - l)$ operations when recursing, so we can just use a BIT with lower_bound and move the left endpoint and right endpoint like how you would do it in Mo’s. CodeForces 1921D. Balanced Subsequences: Relax the condition, and let $f(n, m, k)$ denote the number of bracket sequences such that the longest bracket subsequence is at most of length $2k$, then, the answer we are looking for is $f(n, m, k) - f(n, m, k - 1)$. We find that the recursion is [f(n, m, k) = \begin{cases}\binom{n + m}{n} &amp; \text{if $k \geq \min(n, m)$} f(n, m - 1, k) + f(n - 1, m, k - 1) &amp; \text{otherwise} \end{cases}] this leads us to guessing that $f(n, m, k) = \binom{n + m}{k}$ which can be proven from induction. BOJ 1144. 싼 비용: The main idea is noting that we can use DP on broken profile since we can incrementally add the tiles. However, the state is more involved than a simple bitmask - it needs to convey the information of which tiles are connected, so we need to use 3 bits per position, and then we can do a simple casework for the dp transition. Normalizing the bitmask, such that the first nonzero bit is assigned as 1, and so forth is necessary since it cuts down the number of states drastically, related to the Bell number (number of partition of n distinct objects). This gives an upperbound on the time complexity - $O(nm^2B_m\log B_m)$ which is sufficient. PACNW 2019H. Windmill Pivot: I was able to get the main idea during the virtual, though I didn’t realize the solution I have was sufficient. The key sentence in the question is that after 360 degree rotation, you are guaranteed to have reached back to your original position, which makes implementation easy. Note that there are $O(n^2)$ interesting lines arising from given $n$ points, and for each interesting lines, we can compute the next pivot in $O(n^2\log n)$ by angle sorting, so we have a functional graph with $O(n^2)$ vertices, and we only have to iterate over all the cycles which takes linear time, so in total, the time complexity is $O(n^2\log n)$. PACNW 2023G. Matrix Fraud: We were not able to make much progress in the actual contest, though Vedant did mention he was able to solve it if $r \geq c$. Note that “column”-banded binary matrix is also “row”-banded binary matrix, so we can transpose to get $r \ge c$. Then, we simply define $f(r, c_l, c_r)$ to be the cost to modify rows $[1, r]$ such that in row $r$, we have ones in the interval $[c_l, c_r]$. The naive transition takes $O(c^2)$, but note that the area querying is a prefix rectangle, so we can make the transition $O(1)$. Hence, the DP takes $O(rc^2) = O(rc\sqrt{rc})$ which is sufficient enough to pass. CodeForces 1672E. notepad. exe: I still cannot believe I didn’t solve it back then, but I still struggled to solve this right now lol. We can find $S = \sum_{i} l_i + n - 1$ in less than $30$ queries. Then, we focus on the height $h \in [1, n]$. Clearly, we don’t care about width being larger than $\frac{S}{h}$ since we can attain $S$. Also, in the best case scenario where no space is wasted (no trailing spaces in each line), the total characters used is $S - (h - 1)$, so we have a bound on $w$ which is $[(S - (h - 1)) / h, S / h]$. Clearly, this interval always contain at most $1$ integer, so we can simply query the width in the interval for each $h \in [1, n]$ which takes exactly $n$ queries, so we are done. CodeForces 1672F2. Checker for Array Shuffling: Upsolved, had to read the editorial for the big picture. Considering the directed graph with edges from $a_i$ to $b_i$. IOI 2013. Cave: It becomes very trivial after noting that $70000 &gt; N(\log N + 1)$. We iterate over the doors in an increasing order, and I toggled all $\log N$ bits, and then there are two possibilities - the mask or the negation of the mask, and we can check that manually once more. Apparently we could simply do a binary search by toggling all the switches in the range $[l, r]$. CodeForces 1819C. The Fox and the Complete Tree Traversal: The subgraph of the form of one vertex with degree $3$, and each neighbor not being a leaf must not exist in order for the cycle to exist. If no such subgraph exists, then, the graph is of the form of a diameter and some vertices on the diameter having a leaf neighbor not on the diameter. Then, we can simply traverse from left to right, right to left jumping which is easy to prove. CodeForces 1819D. Misha and Apples: Just maintaining if at position $i$, if the bag can get cleared, and the maximum value achievable afterwards. CodeForces 1930F. Maximize the Difference: Note that $f(b)$ can be computed by finding the maximum of $b_i \&amp; ~ b_j$. Then, for adding $v$, we add all the possible submasks of $v$ into $S_1$, and $~v$ into $S_2$ via DFSing. Each submask gets visited at most once and the degree of each mask is $O(\log N)$, so the update takes $O(N\log N)$ and query takes constant time as we can simply check whenever we add a mask to a set, whether the other set already contained the mask. Thus, $O(N\log N + Q)$. "
    }, {
    "id": 7,
    "url": "http://localhost:4000/math-cs-blog/February-problem-solving/",
    "title": "February Problem Solving",
    "body": "2024/02/11 - CodeForces 1922F. Replace on Segment: Note that we should never do two operations that intersect: $[l_1, r_1]$, $[l_2, r_2]$, $l_1 \le l_2 \le r_1 \le r_2$. Then, we can compute the dp recurrence for $f(l, r, k)$, $g(l, r, k)$ where $f$ is the minimum number of operation for the segment $[l, r]$ to be equal to $k$, $g$ is the minimum number of operation for the segment $[l, r]$ to be all different from $k$. This results in an $O(n^4)$ dp. CCO 2018. Boring Lectures: Offline deletion + Segment tree. We can use the idea used in offline dynamic connectivity, but we cannot naively do this since $N \le 10^6$, so it would result in $O(N\log N\log Q)$ which is too much, so we note that only $Q$ values are updated, so we only change those values, and leave the $N - Q$ values, compute the values for them before and do the offline dynamic connectivity style divide and conquer which results in $O(N\log N + Q\log N\log Q)$ which fits in the TL. 별 보러 가자: Recall for Manhattan distance:       [   x_1 - x_2   +   y_1 - y_2   = \max(x_1 + y_1 - (x_2 + y_2), -(x_1 + y_1) + (x_2 + y_2), x_1 - y_1 - (x_2 - y_2), x_2 - y_2 - (x_1 - y_1))]   then, we can compute $dp[N][M]$, the maximum value of sum of $R_i$ over $N$ days, $M$ observations in $O(NM)$ by realizing that suboptimal values will always be smaller due to the $\max$ operator. All Colourings: Computing the values directly is hard, so we compute the values $dp[mask]$ - the number of ways satisfying at least the edges in the mask which is trivial - DSU/DFS and then simply $K^{CC}$. Then, we can do a Möbius transformation to retrieve the $dp’[mask]$ - the number of ways satisfying exactly the edges in the mask. CERC 2016. Easy Equation: Vieta jumping + BFS. CodeForces 1919F2. Wine Factory (Hard Version): Note that we can model this problem as a flow problem with each water tower $i$ has an incoming edge from the source with capacity $a_i$ and outgoing edge to a sink with capacity $b_i$, and tower $i$ has an edge to $i + 1$ with capacity $c_i$. Considering the minimum cut, we note that only $a_i$ or $b_i$ will be in the cut, and we can maintain this dynamically with a segment tree where for each node, we have a $2 \times 2$ matrix representing where the left endpoint and the right endpoint belongs. NWERC 2022. Faster Than Light: We notice that for a positive slope line, in order for the line to go through all the rectangles, it must be between the top left corner and the bottom right corner, so we can consider the convex hull of the top left corner and the convex hull of the bottom right corner and check if the two polygons intersect, which can be done in linear time using Minkowski sum. Other cases can be dealt in a similar fashion. NWERC 2022. Last Guess: Flow with lowerbound. The sum of greens and yellows bound the number of a specific letter, model the flow as a matching between the positions and the letters. SWERC 2013. It Can Be Arranged: Flow with lowerbound. CodeForces 1924C. Fractal Origami: The formula is pretty evident, simple geometric series, and to implement the solution, we just have to implement $Z_p[\sqrt{2}]$, and this is fine since $2$ is not a quadratic residue in this $p$. NWERC 2022. Alternating Algorithm: Note that we can reduce the problem into the case where we only have 0’s and 1’s by letting the smaller out of the last two elements that were swapped to be denoted as $x$, then, categorize all the elements as $\le x$ or $&gt; x$. After this reduction, note that the answer is lowerbounded by the number of moves for one zero to move into place + the number of zeros after it. Actually, this lowerbound is in fact the answer since if a zero gets blocked by a previous zero for couple operations, then, the value is accounted for by the earlier zeros. With this observation, we can maintain this value using a RURQ data structure, namely, a lazy segment tree, which yields a $O(n\log n)$ solution. NWERC 2022. Kebab Pizza: A lot of casework. The main idea is to represent the pizza slices as the edges and toppings as vertices, and if there is a vertex with three nonleaves neighbors, it is impossible, otherwise, there are two cases: one connected component is always good, if not, if there is a cycle, it is bad. BOJ 13727. 5차원 구사과 초콜릿: Bitmask DP + Berlekamp-Massey. Note that each $2 \times 2 \times 2 \times 2$ layer has to be filled up by itself or the layer that comes after it, so this gives a nice approach to compute the dp $f(l, mask, b)$ which represents $l$th layer, blocks that are on in $mask$ is filled up and we only used subset of blocks $1$, …, $b$ in this layer. This gives a $O(2^{16}2^5L)$ solution for the first $L$ layers which is not enough, so we need to use Berlekamp-Massey after computing the first $300$ values or so, then, we can find the linear recurrence. "
    }, {
    "id": 8,
    "url": "http://localhost:4000/math-cs-blog/January-problem-solving/",
    "title": "January Problem Solving",
    "body": "2024/01/09 - Spotify Challenge 2010. Apparatus: The problem is asking the number of bijective functions $f \colon [n] \to [n]$ such that for the given input $(S_i, T_i)$, $f(S_i) = T_i$. Note that if we can decompose the domain $[n]$ into disjoint sets that are of the form $\bigcap_{i \in I} S_i$, we can simply compute the product of the number of permutations in each disjoint set. We can do this by maintaining the disjoint sets induced by $S_1, \dots, S_{i - 1}$ and inserting a new set $S_i$ can be done in $O(n)$, so the time complexity is $O(n^2)$. BAPC 2017. Ghostbusters: We can consider the bipartite graph $G$ with rows and columns being the vertices. We find the connected components of $G$, and for each connected component, we compute the maximum spanning tree since if there is a cycle, we can always remove one of the edges to have a higher probability, and we are to find [\operatorname{argmax}{T \colon spanning tree} \prod{e_i \in T} p_i = \operatorname{argmax}{T \colon spanning tree} \sum{e_i \in T} \ln p_i] since $\ln$ is monotonic. The time complexity should be $O(E\log E) = O(nm\log nm)$. CodeForces 1553G: Notice that the answer will be at most $2$ since $2 \mid a_i(a_i + 1)$ for any $a_i$, so we can always create two nodes to satisfy the condition. Also, we can compute the connected components by storing $i$ in each prime divisor of $a_i$, and for each prime number, we connect all the vertices stored there. This covers when the answer is zero. For the one case, for each $i$, we compute the prime divisors of $a_i(a_i + 1)$ and which connected components it will connect when added: let $S_i$ denote the ids of the connected components. $|S_i| \leq 8$, so we can precompute all the connected component pairs that can be connected with one additional vertex in $O(\binom{8}{2}n)$. The overall time complexity will be $O(A + n\log A)$, where $A$ is the maximum possible value of $a_i$. CodeSprint LA 2023. Food Mixing: The problem statement can be reduced down to:  Given a set $S$ of 2D points $P_1, \dots, P_n$, check whether $(x, y) \in \operatorname{conv}(S)$.  If so, output a valid convex combination that results in $(x, y)$. This can be done by computing the convex hull of $S$, and check whether $(x, y)$ is in the convex polygon, and if so, split the convex polygon into triangles of the form $Q_1Q_iQ_{i + 1}$, where we can retrieve the coefficients using line intersection. There are some edge cases, such as when the convex polygon is degenerate, but that’s Geo for ya. BOJ 31027. 물고기 게임: Simple casework. BOJ 31030. 순열과 수열: We note that for disjoint cycles of $A$, they do not affect the corresponding $B$ values, so we focus on individual cycles. Consider the cycle $i, A_i, A_{A_i}, \dots$. If we set $B_i = k$, $B_{A_i} = A_k$, $B_{A_{A_i}} = A_{A_k}, \dots$, and the only condition that needs to be satisfied is the length of the cycle $k$ is in must divide the cycle length of $i$. For each cycle, we can do this in $O(NC)$, so the solution runs in $O(\sum NC) = O(N^2)$. Dwango Programming Contest 6th. Cookie Distribution: Application of the so-called “product trick”. The product can be viewed as the number of ways to color one cookie red for each child. Let $dp[i][j]$ be the number of ways such that in the first $i$ days, $j$ children get red cookies. The dp recurrence is [dp[i][j] = \sum_{m = 0}^{\min(a_i, j)} dp[i - 1][j - m]\binom{n - j + m}{m}\binom{n - m}{a_i - m}] and the answer is $dp[k][n]$. This can be computed in $O(kn^2)$ ABC 231G. Balls in Boxes: Another application of “product trick”. This time, we start with some number of balls, so we first compute the number of ways to color $j$ balls when considering the first $i$ boxes: $dp[i][j]$. [dp[i][j] = dp[i - 1][j] + a[i]dp[i - 1][j - 1]] and then for each $0 \leq m \leq n$, the value $dp[n][m]$ will contribute [\frac{1}{n^m}dp[n][m]\binom{k}{n - m}(n - m)!n^{k - n + m}] CodeForces 1919F1. Wine Factory (Easy Version): We can model each water tower as a ReLU function: $f_i(x) = \max(x + a_i - b_i, 0)$, and ReLU functions of the form $g(x) = \max(x + a, 0) + b$ is indeed a monoid (by introducing an artificial identity function), so we can use a segment tree to compute the remaining water which is $seg[0…n - 1](0)$. SWERC 2015. Game of Cards: Simple Sprague-Grundy theorem application SWERC 2017. Cordan Bleu: We note that the distance from the restaurant to the wine merchants is included regardless. To match a wine cellar with a courier, it is a weighted bipartite matching which can be solved using MCMF or Hungarian algorithm. The time limit is quite tight. SWERC 2016. Passwords: We make an AC-automaton with the blacklisted words, and then propagate the blacklist information through suffix links/children. Then, we can do a dynamic programming with the state being $(len, pos, has\_low, has\_up, has\_num)$. BOJ 31032. 트리의 개수: Using indicator variables, we can write the desired sum as the following: [\sum_{j = 1}^{K}g_j(T) = \sum_{j = 1}^{K}\sum_{T’\subseteq T}1 + \sum_{e \in E’}[A_u \leq j \lor A_v \leq j] - \sum_{v \in V’}[A_v \leq j]] All three terms can be computed by first rearranging and then using tree dp, where $dp[u]$ is the number of connected subgraphs that has $u$ as the closest vertex to the root, and $revdp[u]$ is the number of connected subgraphs that includes $par[u]$, and does not include $u$. The recurrences are [dp[u] = \prod_{i = 1}^k (1 + dp[c_i])] and [revdp[u] = (revdp[par[u]] + 1) \frac{dp[par[u]]}{1 + dp[u]}] The time complexity is $O(n)$. BOJ 30989. 다항함수의 미분과 나머지: Essentially, the condition with the kth derivative is: [f^{(k)}(x) = \sum_{i = k}^n (i)kc_ix^{i - k} = \sum{j = 0}^d r_jt^j] and $(i)_k \pmod{m}$ can be computed using a segment tree or factorizing $m$ into its prime factors and doing a sliding window, maintaining the power of $p$ and the product that is coprime with $p$. Then, $(i)_kc_i \equiv s_j \pmod{m}$, so we can solve this by extended euclidean algorithm, and find the range of $c_i$. There is a lot of edge cases that we need to consider, which is left as an exercise for the reader. USACO Jan20 Platinum. Minimizing Haybales: The main observation is that for each $1 \leq i \leq N$, the cardinality of the set $S_i := \{j \in [i - 1] \colon |h_j - h_i| &gt; K\}$ is invariant under the given operation, so the idea for the solution is to take the smallest $h_i$ that satisfies $|S_i| = 0$, and remove $h_i$ from the remaining $S_j$’s. This can be done via square root decomposition or segment tree. "
    }, {
    "id": 9,
    "url": "http://localhost:4000/math-cs-blog/CodeForces-Pinely-Round-3/",
    "title": "CodeForces Pinely Round 3",
    "body": "2023/12/23 - I am very happy with my performance in the round despite not participating for nearly 6 months. Back to IM! Before Contest: I warmed up by solving Pinely Round 2. A: We compute the optimal scenario and the pessimal scenario: Optimal is assuming that when every time someone comes online, the person has yet to read the post. Pessimal is assuming that every time someone comes online, if it is possible, we assume the person has already read the post. This should yield a simple $O(n)$ solution. B: We notice that when we choose $x$ and then $y &gt; x$, the part where it is $&lt; x$ does not change at all in the second operation. This observation motivates a greedy solution, where if $i…j$ is already in the right order as a subsequence of the permutation, we we should do an operation with $j$. Storing the indices of $1$ to $n$ and scanning in that order should lead to an $O(n)$ solution. C: The crucial observation is that we could think of the operation as rotating a $n + 1$ length array, where the initial array is $a_1$, $\dots$, $a_n$, $a_{n + 1}$, and [a_{n + 1} = \frac{n(n + 1)}{2} - \sum_{i = 1}^n a_i] Then, we only care about $k \pmod{n + 1}$ number of operations, which can be simulated in $O(k)$ using a deque or use the std::rotate() function. D: Dominoes that are placed horizontally do not affect the row count, and vice versa, so we can color the vertical dominoes by scanning row by row, making sure that there are only even number of vertical dominoes occupying each row, and similarly with the columns. The time complexity is $O(nm)$. E: If we know which hour to start, we can greedily complete the quests, completing whichever is completable, but the number of hours is $k \leq 10^9$, so we have to find a smarter approach. We use dynamic programming: $dp[u]$ represents the fastest time that the quests dependent on quest $u$ can be completed, and it satisfies the following recursion: [dp[u] = \max_{v \in N(u)} \begin{cases}  dp[v] &amp; \text{if $h[u] \leq h[v]$}   dp[v] + (1, 0) &amp; \text{if $h[u] &gt; h[v]$} \end{cases}] and then, we add a dummy node that represents the super source with edges from the super source to the sources in the original graph. Using storing a suffix maximum, we can iterate all possible starting time, and choose whichever takes the shortest amount of time. The time complexity should be $O(n + m)$. F: Let $S = \oplus_{i = L}^R a_i$, $x = \oplus_{i = L}^k a_i$, $y = \oplus_{i = k + 1}^R a_i$, then, $S = x \oplus y$, and there are two cases: i) $S = 0$ Then, for any $L &lt; k &lt; R$, we can attain $[L, k]$ and $[k + 1, R]$. ii) $S &gt; 0$ Then, whichever of $x$ and $y$ that has the MSB of $S$ can be attained. We maintain an array $msbs[i]$ which stores the MSB of a “good” array, and another array $is\_zero[i]$ which is true if there is a “good” array with xor sum zero. The time complexity should be $O(n^2)$. Actual Contest: A: The only case that is not achievable is when there exists a point with a positive $x$-value, a point with a positive $y$-value, a point with a negative $x$-value, and a point with a negative $y$-value, where each point does not necessarily have to be different. This can be checked in $O(n)$. B: Considering the binary representation. Since each $a_i$ is distinct, there exists a position $j$ where not all $a_i$ shares the same value for that position, and we can find the first position where they differ. Then, $2^j$ is the answer. The time complexity is $O(n\log\text{MAX})$ if done naively, otherwise, $O(n + \log\text{MAX})$ is possible. C: Note that if there exists a pair of intervals intersecting, it is always better to make them nested, and there exists only one configuration that satisfies it, which can be found by sorting the $l$ values and the $r$ values. The time complexity is $O(n\log n)$ D: Each $a_i$ is independent of each other, so we should focus on a single one. For $a_i$, after performing $m$ of the operation, it is possible to make $m + 1$ copies of $\frac{a_i + km}{m + 1} = k + \frac{a_i - k}{m + 1}$. So we need to make the value of $\frac{a_i - k}{m + 1}$ the same for every $i$. Let $g = \gcd_{i = 1}^n (a_i - k)$, then, $m_i = \frac{a_i - k}{g} - 1$. The time complexity is $O(n + \log\text{MAX})$. E: If we simply turn on all the switches, only the perfect squares will remain, so for $n$ that satisfies $\lfloor\sqrt{n}\rfloor \leq \lfloor\frac{n}{5}\rfloor$, which holds true for all $n \geq 20$, we can always satisfy the condition. Now, for $n \leq 19$, we focus on the vectors $v_i \in \mathbb{Z}_2^n$, representing the lights that are turned on by switch $i$, and $v_1$, $\dots$, $v_n$ is the basis, so there are $\binom{n}{1} + \binom{n}{2} + \binom{n}{3} = O(n^3)$ valid combinations of switches. Caching the valid combination of switches, we can achieve $O(Tn^4)$. F1 &amp; F2: Let $dp[i]$ be the number of valid placements of $1$ to $i$ that satisfies the restrictions $a_1$, $\dots$, $a_i$, and let $c = i - a_i$. Suppose the next position that isn’t $-1$ is $j &gt; i$. Then, the recurrence is [dp[j] = dp[i]\sum_{k = 0}^{a_j - a_i}\binom{j - i}{k}\binom{c}{a_j - a_i - k}\binom{j - i}{a_j - a_i - k}(a_i - a_j - k)!\binom{j - a_j + k}{k}k!] Since $a_i$ must be an increasing sequence (excluding $-1$s) for the restriction to have a valid permutation, the time complexity is $O(n)$. Afterthought: The quality of each problem was amazing. I hope the following Div 1+2 rounds also have this high-quality problems. "
    }, {
    "id": 10,
    "url": "http://localhost:4000/math-cs-blog/February-problems/",
    "title": "February Problem-solving",
    "body": "2023/02/25 - CSES Counting Tiles  Solution This technique is called “DP on broken profile”. Interesting to note thatproblem K from ICPC PACNW Regionals from today can also be solved using this technique(Thankfully, in the contest, I was able to solve it quite straightforwardly). This problem is easier as we only have tomaintain a bitmask of which tiles are open. This allows a$O(nm2^n)$ solution. The dp states are $dp[i][j][mask]$, where$(i, j)$ is the corner, but since $dp[i][j]$ relies solely on$dp[i][j - 1]$, we can drop the first two dimensions leadingto a $O(2^n)$ memory. CodeForces 662C  Solution Bitmask DP + Finding the linear recurrence. We can first think ofeach column as a bitmask of length $n$, labeling them $col_1$,$col_2$, $\dots$, $col_m$. Then, the rows that are being inversedcould be also represented as a bitmask of length $n$, denoted as$mask$. Then, we are calculating the $mask$ that minimizes the sum \[\sum_{i = 1}^{m} \min(pc(mask \oplus col_i), n - pc(mask \oplus col_i))\] where $pc$ is the popcount function. This takes $O(2^n m)$, which is very slow. In order to improve this, we define $dp[k][mask]$ to be the number of $col_i$ such that $pc(col_i, mask) = k$. We can easily calculate $dp[0][mask]$ in $O(m)$ as $mask$ has to equal $col_i$. Suppose $k &gt; 0$, and $pc(col_i, mask) = k$. We can consider a position $p$, such that $col_i$ and $mask$ differs in. Then, there would be $dp[k - 1][mask \oplus 2^p]$ possible columns, but it could be possible that $col_i$ and $mask \oplus 2^p$ differs in position $p$ again, so we have to subtract $dp[k - 2][mask]$, and repeating this process, if $pmask$ denotes $mask \oplus 2^p$, we get \[dp[k - 1][pmask] - dp[k - 2][mask] + dp[k - 3][pmask] - \dots\] If we sum for all $0 \leq p \leq n - 1$, then we would count each $col_i$ $k$ times, so $k \cdot dp[k][mask]$. Hence, \[dp[k][mask] = \frac{1}{k} \sum_{p = 0}^{n - 1} \sum_{f = 1}^{k} (-1)^{f - 1} dp[k - f][mask \oplus (2^p \cdot (f \bmod 2))]\] There are $n \cdot 2^n$ states and $n^2$ per transition, yielding a $O(n^3 \cdot 2^n)$ which is still too slow. Note that \[\sum_{p = 0}^{n - 1} \sum_{f = 3}^{k} (-1)^{f - 1} dp[k - f][mask \oplus (2^p \cdot (f \bmod 2))]= (k - 2)dp[k - 2][mask]\] so \[dp[k][mask] = \frac{1}{k} \left((k - 2 - n)dp[k - 2][mask] +\sum_{p = 0}^{n - 1} dp[k - 1][mask \oplus 2^p]\right)\] yielding a $O(n)$ transition, hence, a $O(n^2 \cdot 2^n)$ solution. CEOI 2016 Kangaroo  Solution Connected component DP. Note that the problem can be restated as counting the number of permutation $p_1$, $\dots$, $p_n$, such that $p_1 = cs$, $p_n = cf$, and for all $2 \leq i \leq n - 1$, either $p_{i - 1} &lt; p_i &gt; p_{i + 1}$ or $p_{i - 1} &gt; p_i &lt; p_{i + 1}$ holds. Then, we can proceed with the typical dp states $dp[i][j]$ which represents the number of correct permutations, partially filled with $1$ to $i$, that has $j$ connected components. We note that because we insert the elements in increasing order, we can only either merge two connected components or add an independent component. Obviously, the corner cases are when $i = cs$ or $i = cf$, but they are trivial. Thus, we get a $O(n^2)$ solution with $O(n)$ memory usage. CodeForces 1634F  Solution Modified prefix sum. Consider $C_i = A_i - B_i$, and $D_1 = C_1$, $D_2 = C_2 - C_1$, $D_i =C_i - C_{i - 1} - C_{i - 2}$. Note that $A = B$ if and only if $D_i = 0$ for all $i$. Also, for each query $[l, r]$, only $D_l \mathrel{+}= 1$, $D_{r + 1} \mathrel{-}= F_{r - l + 2}$, $D_{r + 2} \mathrel{-}= F_{r - l + 1}$. So we can easily update $D$ by precomputing the Fibonacci numbers. Hence, we get a$O(N + Q)$ solution. "
    }, {
    "id": 11,
    "url": "http://localhost:4000/math-cs-blog/Aho-Corasick-and-applications/",
    "title": "Aho-Corasick and Applications",
    "body": "2023/01/15 - Prerequisites: Aho-Corasick Problems CodeForces Edu Round 94 F  Solution  Bruteforce + Aho-Corasick + DP  Note that the maximum number of x-prime strings for $x \leq 20$ is $2399$ and the size of theautomaton created by those strings is at most $5000$. If we let $m$ to be the size of the ACAutomaton, we can get a simple $\mathcal{O}(|S|m)$ DP where a dp state $dp_{i, j}$ stores theminimum number of characters removed in the prefix $S[1\dots i]$, such that we have the resultingstring ending up at vertex $j$ in the AC Automaton. "
    }, {
    "id": 12,
    "url": "http://localhost:4000/math-cs-blog/first-post/",
    "title": "First Post",
    "body": "2023/01/05 - Hello! I am Youngmin Park, a first-year math &amp; compsci major at UC Berkeley. I decided to make a blog to becomea more organized person as my notes have been everywhere, very disorganized. Hopefully, this would change. Anyways, I will probably write things related to my studies, and competitive programming stuff. "
    }, {
    "id": 13,
    "url": "http://localhost:4000/math-cs-blog/January-problems-1/",
    "title": "January Problem-solving (1)",
    "body": "2023/01/05 - ARC 88E Papple Sort  Solution Without loss of generality, let the length of the string be even. Consider for each character $c$, the set $S_c = \{i | s_i = c\}$. In the resulting palindrome, each index in $S_c$ is pairedwith another index in $S_c$. Since it is unideal to swap between two adjacent characters that are the same, the ordering of the indicesin $S_c$ does not change. Hence, The smallest index gets paired with the largest index, and so on. Now, we can transform the given problem into the following problem:  We have $k$ pairs with distinct left and right indices. We assign $0\sim k-1$ for each pair. If a pair getsassigned $i$, then $a_l = i, a_r = 2k - i$ for the array $a$ of size $2k$. What is the minimum number of inversion of $a$?  Thinking of the pairs as intervals, it should be clear that for nested pairs, the inversion count is either 0 or 2,non-nested, intersecting pairs always have an inversion count of 1, and non-intersecting pairs always have an inversion count of 2. Hence, we have to minimize the inversion count for every nested pairs.    Lemma. It is possible to obtain an inversion count of 0 for each nested pair.   Proof. Think of the pairs as vertices, and whenever a pair is nested in another pair, add a directed edge to it. Clearly,this digraph is acylic, so if we label the pairs accordingly to the topological sort, we can achieve the inversion count of 0.   So, the problem is reduced down to calculating the total number of intersecting pairs, and non-intersecting pairs whichcan be solved using a BIT/Segment Tree in $\mathcal{O}(N\log N)$.  For odd length strings, we can manually add the inversion count of the one character by iterating over the pairs. CodeForces Round #473 Div 2F  Solution  Offline query, XOR Basis, and the Fundamental Theorem of Linear Algebra solves the problem(Technically, we could store the basis of each prefix since $|B|\leq 20$ as $a_i &lt; 2^{20}$, and $N \leq 10^5$,so we could solve the queries online). We could think of the 20-bit integers as vectors in $\mathbb{Z}_2^{20}$, and this allows usto transform the problem into a straightforward linear algebra problem:  Let $T:\mathbb{Z}_2^N\mapsto\mathbb{Z}_2^{20}$, $T(v_1, v_2, \ldots, v_N) = \oplus_{i = 1}^N v_ia_i. $Calculate the number of vector $u$, such that $Tu = x$.  Clearly, if $x$ is not in the span of the basis of $a_1, a_2, \ldots, a_N$, $B$, the answer is zero. Now, suppose $Tu = x$. Then, if $Tv = x \implies T(u - v) = 0$, hence, the answer is the number ofvectors in the null space of $T$. By the Fundamental Theorem of Linear Algebra, $\dim\operatorname{Null}(T) = \dim V - \dim\operatorname{range}(T) = N - |B|$, hence, $|\operatorname{Null}(T)| = 2^{N - |B|}$.  Calculating the basis of the prefix of $a$ can be done incrementally in $\mathcal{O}(\log\max a_i)$ andchecking if $x$ is in the basis can be done in a similar fashion, which yields a $\mathcal{O}((N+Q)\log\max a_i)$solution. BOJ 14859 Three-way Coprime  Description (for those who can't read Korean)  Given a sequence of length $N, N \leq 10^5, a_1, a_2, \ldots, a_N$, $1 \leq a_i \leq 10^6$,count all triplets $(i, j, k), 1 \leq i &lt; j &lt; k \leq N$ that satisfies $\gcd(a_i, a_j, a_k) = 1$.   Solution  Typical number theory approach where we iterate over the multiples of an integer.  Let freq be the frequency array, where freq[i] stores $\vert\{j : i \vert a_j \}\vert$, and cnt[d] bethe number of triplets $(i, j, k)$, such that $\gcd(a_i, a_j, a_k) = d$. Clearly, answer is cnt[1]. \[cnt[d] = \binom{freq[i]}{3} - \sum_{j = 2}^{\left\lfloor\frac{\max a_i}{d}\right\rfloor} cnt[jd]\]POI 2005 Template  Solution  KMP + A bit of observations  Possible templates of $S$ are itself and the templates of $S[0:\pi[|S| - 1] - 1]$. Note that if $\pi[|S| - 1] &gt;= \frac{|S|}{2}$, then $S[0:\pi[|S| - 1] - 1]$ is indeed a template. So we only have to check when the value of the prefix function halves or more. It is clear thatthis can only happen $\mathcal{O}(\log |S|)$ times, so even with a naive $\mathcal{O}(|S|)$ checking,we get a $\mathcal{O}(|S|\log |S|)$ solution. CodeForces Edu Round #137 F  Solution  Contribution technique + Segment Tree storing matrices.  It is easy to see that we could count the contribution of each integer in $0\dots 3\times 10^5$. For each integer, we could consider a dp, and the transition can be modelled using $2\times 2$matrices, suggesting we should use a segment tree. Also, transitioning from $i$ to $i + 1$ can beeasily done by storing the indices of segments that have the left boundary as $i + 1$ or right boundaryas $i$. This allows a $\mathcal{O}((N + MAX)\log N)$ with a constant factor of 8 for matrix multiplication. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});