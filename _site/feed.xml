<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Youngmin&apos;s Blog</title>
    <description>Yet Another CS Blog</description>
    <link>http://localhost:4000/math-cs-blog/</link>
    <atom:link href="http://localhost:4000/math-cs-blog/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 06 Jul 2024 18:21:24 -0700</pubDate>
    <lastBuildDate>Sat, 06 Jul 2024 18:21:24 -0700</lastBuildDate>
    <generator>Jekyll v4.3.1</generator>
    
      <item>
        <title>2024/07/06 Problem-solving</title>
        <description>&lt;h3 id=&quot;boj-28427-tricknology&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/28427&quot;&gt;BOJ 28427. Tricknology&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The condition on the pair $(x, y)$ can be rewritten as $2x + 1$ is prime, so we only need the prefix sum on this predicate, thus, this can be solved in $O(Q + \text{MAX})$.&lt;/p&gt;

&lt;h3 id=&quot;open-cup-20202021---gp-of-suwon-find-the-xor&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20557&quot;&gt;Open Cup 2020/2021 - GP of Suwon. Find the XOR&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;It is a classic setup using DFS tree + backedges to get all the cycles, and then get the xor basis of the cycles. Then, we see that for every distance $d(i, j)$, it can be decomposed into two parts - $d(i) \oplus d(j)$ which is from traversing the DFS tree, and then some combination of the cycles in the xor basis to get the maximum possible weight. The first part can be computed very efficiently for each query using prefix sum, now for the second part, we first write the xor basis in the RREF, and let it be denoted by $C_1, \ldots, C_k$, with the most significant bits being $2^{i_1}, \ldots, 2^{i_k}$. Since it is in RREF, we know that for each $C_j$, it does not have any of the $2^{i_x}$ for $x \neq j$. This is the main observation. Now, for each $d(i, j)$, $C_x$ is only included if $d(i) \oplus d(j)$ does not have $2^{i_x}$. This lets us use prefix sum (again!) to finish the problem. The time complexity is $O((N + Q)\log\text{MAX})$.&lt;/p&gt;

&lt;h3 id=&quot;toki-troc14-tree-game&quot;&gt;&lt;a href=&quot;https://tlx.toki.id/problems/troc-14/H/&quot;&gt;TOKI TROC14. Tree Game&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The idea is quite simple - in a line case, the problem reduces to range flip which can be done with a lazy segment tree, so we can use HLD + subtree queries (by ordering the heavy child first), and we maintain a slack variable that stores the light children sum. Note that computing $cnt[u]$, the number of white nodes in a subtree is straightforward, so we can manually compute it for the node and its heavy child, and we subtract by the slack variable, so when updating the path, we would first subtract the corresponding value for each light edge we go up, update the path, and then add back the values for the light edge. The time complexity would be $O(Q\log^2 N)$.&lt;/p&gt;

&lt;p&gt;P.S. I had a major bug in my code that computed the subtree size wrong, but somehow it passed 10 tests…&lt;/p&gt;

&lt;h3 id=&quot;seerc-2019a-max-or-min&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17955&quot;&gt;SEERC 2019A. Max or Min&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The idea is quite simple - for a fixed target value $x$, the only thing we care about each number is whether they are greater or less than $x$, and then, since the array is circular, we will always have a closed interval with the left and right endpoints being $x$, and after flipping some number first, the number of operations needed is simply the size of the interval plus the number of contiguous intervals of the same type. This can be nicely maintained using a segment tree storing $2 \times 2$ matrices.&lt;/p&gt;

&lt;h3 id=&quot;nwerc-2009i-simple-polygon&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3679&quot;&gt;NWERC 2009I. Simple Polygon&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Convex Hull problem. The idea is that if we get a lower convex hull, every other point will lie nicely above it, so we can sort them by the x-coordinate and append it.&lt;/p&gt;

&lt;h3 id=&quot;icpc-korea-prelim-2014e-highway&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10254&quot;&gt;ICPC Korea Prelim 2014E. Highway&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Rotating Calipers. Note that unlike the furthest point away from a line can be found by ternary search since the distance is convex, given that all the points are on one side of the line, the furthest point away from a point is &lt;strong&gt;not&lt;/strong&gt; convex!! Hence, we have to resort to comparing angles until we get angles closest to opposite. Note that we don’t move the calipers when they are parallel?&lt;/p&gt;

&lt;h3 id=&quot;ioi-2013-dreaming&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8872&quot;&gt;IOI 2013. Dreaming&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Tree DP + Greedy. We can easily prove that for the newly added edges, it is never optimal to have different endpoints for a tree in the forest. Thus, we only have to consider which vertices will connect to different trees. Then, within the tree, the only thing that matters is its diameter, and the vertex that minimizes the maximum distance from itself. Suppose we have $k$ trees, each with maximum distance $d_1 \le d_2 \le \ldots d_k$. We can prove that it is always optimal to connect $T_k$ with rest of the trees like a star.&lt;/p&gt;

&lt;h3 id=&quot;boj-13974-파일-합치기-2&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13974&quot;&gt;BOJ 13974. 파일 합치기 2&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Knuth Optimization. The main idea is that if $opt[i][j]$ is the optimum for an interval $[i, j]$ and the cost array satisfies monge array and $C[a][d] \ge C[b][c]$ for $a \le b \le c \le d$, we have that&lt;/p&gt;

\[opt[i][j - 1] \le opt[i][j] \le opt[i + 1][j]\]

&lt;p&gt;which allows us to iterate in increasing order of interval length to get $O(N^2)$.&lt;/p&gt;

&lt;h3 id=&quot;arc-74f-lotus-leaves&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc074/tasks/arc074_d&quot;&gt;ARC 74F. Lotus Leaves&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Idea is modeling leaves as an edge between a row and a column, and then we can see that this problem reduces to a minimum cut problem. Beware that the source and sink in this case should be a union of a row and a column, but otherwise a very standard flow problem, with a very chill bound.&lt;/p&gt;

&lt;h3 id=&quot;boi-2009-beetle&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2419&quot;&gt;BOI 2009. Beetle&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Range DP. Very cool idea - instead of thinking about the maximum amount of water the beetle can get, we think about the complement; the minimum number of water to be wasted. Even then, it is somewhat unclear what the DP would look like. Thus, we fix the number of dews to visit to drink - let it be $k$. Then, if we move $x$ distance, the amount of water will decrease by $kx$.&lt;/p&gt;

&lt;h3 id=&quot;boj-11001-김치&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11001&quot;&gt;BOJ 11001. 김치&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DnC Optimization. Since the value we are optimizing for forms a Monge array, it is trivial.&lt;/p&gt;

&lt;h3 id=&quot;boj-14560-communism&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14560&quot;&gt;BOJ 14560. Communism&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;MITM + Merge sorting. $O(n\times 3^{n / 2})$ doesn’t pass, so we must sort smartly - each stage we either add $-x[i]$, $0$, $x[i]$, so we only have to merge these three arrays fast which can be done in a merge sorting fashion, $T(n) = T(n / 3) + O(3^n)$, so $T(n) = O(3^n)$.&lt;/p&gt;

&lt;h3 id=&quot;boj-17526-star-trek&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17526&quot;&gt;BOJ 17526. Star Trek&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Since the slopes are in arbitrary order for the dp in the increasing direction, we consider the reverse direction dp, where $dp[i]$ covers $[i, N]$. Then, we can see the slopes are in monotonic order, so we can do a simple CHT DP in $O(N\log N)$.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1740f-conditional-mix&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1740/problem/F&quot;&gt;CodeForces 1740F. Conditional Mix&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DP. Using Gale-Ryser Theorem, we can see that the necessary and sufficient condition for a multiset with $r_1 \ge \ldots \ge r_n$ is when for each prefix $k$, the following satisfies:&lt;/p&gt;

\[\sum_{i = 1}^k r_i \le \sum_{j = 1}^n \min(k, f_j)\]

&lt;p&gt;Then, we can define the dp state to be $(pos, sum, last)$ and then note that the number of values that can be last for a give pos is $\frac{n}{pos} + 1$, so using prefix sum, the dp can be done in $O(n^2\log n)$.&lt;/p&gt;

</description>
        <pubDate>Sat, 06 Jul 2024 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/math-cs-blog/20240706-problem-solving/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/20240706-problem-solving/</guid>
        
        <category>problem-solving</category>
        
        
      </item>
    
      <item>
        <title>May Problem-solving</title>
        <description>&lt;h3 id=&quot;toki-troc14-tree-game&quot;&gt;&lt;a href=&quot;https://tlx.toki.id/problems/troc-14/H/&quot;&gt;TOKI TROC14. Tree Game&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The idea is quite simple - in a line case, the problem reduces to range flip which can be done with a lazy segment tree, so we can use HLD + subtree queries (by ordering the heavy child first), and we maintain a slack variable that stores the light children sum. Note that computing $cnt[u]$, the number of white nodes in a subtree is straightforward, so we can manually compute it for the node and its heavy child, and we subtract by the slack variable, so when updating the path, we would first subtract the corresponding value for each light edge we go up, update the path, and then add back the values for the light edge. The time complexity would be $O(Q\log^2 N)$.&lt;/p&gt;

&lt;p&gt;P.S. I had a major bug in my code that computed the subtree size wrong, but somehow it passed 10 tests…&lt;/p&gt;

&lt;h3 id=&quot;seerc-2019a-max-or-min&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17955&quot;&gt;SEERC 2019A. Max or Min&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The idea is quite simple - for a fixed target value $x$, the only thing we care about each number is whether they are greater or less than $x$, and then, since the array is circular, we will always have a closed interval with the left and right endpoints being $x$, and after flipping some number first, the number of operations needed is simply the size of the interval plus the number of contiguous intervals of the same type. This can be nicely maintained using a segment tree storing $2 \times 2$ matrices.&lt;/p&gt;

&lt;h3 id=&quot;nwerc-2009i-simple-polygon&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/3679&quot;&gt;NWERC 2009I. Simple Polygon&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Convex Hull problem. The idea is that if we get a lower convex hull, every other point will lie nicely above it, so we can sort them by the x-coordinate and append it.&lt;/p&gt;

&lt;h3 id=&quot;icpc-korea-prelim-2014e-highway&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10254&quot;&gt;ICPC Korea Prelim 2014E. Highway&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Rotating Calipers. Note that unlike the furthest point away from a line can be found by ternary search since the distance is convex, given that all the points are on one side of the line, the furthest point away from a point is &lt;strong&gt;not&lt;/strong&gt; convex!! Hence, we have to resort to comparing angles until we get angles closest to opposite. Note that we don’t move the calipers when they are parallel?&lt;/p&gt;

&lt;h3 id=&quot;ioi-2013-dreaming&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/8872&quot;&gt;IOI 2013. Dreaming&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Tree DP + Greedy. We can easily prove that for the newly added edges, it is never optimal to have different endpoints for a tree in the forest. Thus, we only have to consider which vertices will connect to different trees. Then, within the tree, the only thing that matters is its diameter, and the vertex that minimizes the maximum distance from itself. Suppose we have $k$ trees, each with maximum distance $d_1 \le d_2 \le \ldots d_k$. We can prove that it is always optimal to connect $T_k$ with rest of the trees like a star.&lt;/p&gt;

&lt;h3 id=&quot;boj-13974-파일-합치기-2&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13974&quot;&gt;BOJ 13974. 파일 합치기 2&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Knuth Optimization. The main idea is that if $opt[i][j]$ is the optimum for an interval $[i, j]$ and the cost array satisfies monge array and $C[a][d] \ge C[b][c]$ for $a \le b \le c \le d$, we have that&lt;/p&gt;

\[opt[i][j - 1] \le opt[i][j] \le opt[i + 1][j]\]

&lt;p&gt;which allows us to iterate in increasing order of interval length to get $O(N^2)$.&lt;/p&gt;

&lt;h3 id=&quot;arc-74f-lotus-leaves&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/arc074/tasks/arc074_d&quot;&gt;ARC 74F. Lotus Leaves&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Idea is modeling leaves as an edge between a row and a column, and then we can see that this problem reduces to a minimum cut problem. Beware that the source and sink in this case should be a union of a row and a column, but otherwise a very standard flow problem, with a very chill bound.&lt;/p&gt;

&lt;h3 id=&quot;boi-2009-beetle&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/2419&quot;&gt;BOI 2009. Beetle&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Range DP. Very cool idea - instead of thinking about the maximum amount of water the beetle can get, we think about the complement; the minimum number of water to be wasted. Even then, it is somewhat unclear what the DP would look like. Thus, we fix the number of dews to visit to drink - let it be $k$. Then, if we move $x$ distance, the amount of water will decrease by $kx$.&lt;/p&gt;

&lt;h3 id=&quot;boj-11001-김치&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11001&quot;&gt;BOJ 11001. 김치&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DnC Optimization. Since the value we are optimizing for forms a Monge array, it is trivial.&lt;/p&gt;

&lt;h3 id=&quot;boj-14560-communism&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14560&quot;&gt;BOJ 14560. Communism&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;MITM + Merge sorting. $O(n\times 3^{n / 2})$ doesn’t pass, so we must sort smartly - each stage we either add $-x[i]$, $0$, $x[i]$, so we only have to merge these three arrays fast which can be done in a merge sorting fashion, $T(n) = T(n / 3) + O(3^n)$, so $T(n) = O(3^n)$.&lt;/p&gt;

&lt;h3 id=&quot;boj-17526-star-trek&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17526&quot;&gt;BOJ 17526. Star Trek&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Since the slopes are in arbitrary order for the dp in the increasing direction, we consider the reverse direction dp, where $dp[i]$ covers $[i, N]$. Then, we can see the slopes are in monotonic order, so we can do a simple CHT DP in $O(N\log N)$.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1740f-conditional-mix&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1740/problem/F&quot;&gt;CodeForces 1740F. Conditional Mix&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;DP. Using Gale-Ryser Theorem, we can see that the necessary and sufficient condition for a multiset with $r_1 \ge \ldots \ge r_n$ is when for each prefix $k$, the following satisfies:&lt;/p&gt;

\[\sum_{i = 1}^k r_i \le \sum_{j = 1}^n \min(k, f_j)\]

&lt;p&gt;Then, we can define the dp state to be $(pos, sum, last)$ and then note that the number of values that can be last for a give pos is $\frac{n}{pos} + 1$, so using prefix sum, the dp can be done in $O(n^2\log n)$.&lt;/p&gt;

</description>
        <pubDate>Wed, 29 May 2024 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/math-cs-blog/May-problem-solving/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/May-problem-solving/</guid>
        
        <category>problem-solving</category>
        
        
      </item>
    
      <item>
        <title>Grind for NAC</title>
        <description>&lt;h3 id=&quot;codeforces-1817b-fish-graph&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1817/problem/B&quot;&gt;CodeForces 1817B. Fish Graph&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The special node must be a node with degree greater than or equal to $4$, and has a simple cycle passing through it. Finding a simple cycle going through the node can be found by constructing the dfs tree - if there is no backedge going through the special node, there is no simple cycle going through it. Otherwise, we can take the shortest backedge (i.e, backedge connecting to the node with the smallest depth) and its cycle, and any two additional edges connected to the special node will give us the fish graph.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1817c-similar-polynomials&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1817/problem/C&quot;&gt;CodeForces 1817C. Similar Polynomials&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Since $A(x) \equiv B(x - s)$, the leading coefficient of $A$ and $B$ are the same, let $k$ denote it, and $a$, $b$ denote the second coefficient of $A$, $B$, respectively. By simply expanding, we get that $\frac{b - a}{kd} = s$. Thus, we only have to find $k$, $a$, $b$. This can be done by using Lagrange Interpolation + basic Vieta.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1967c-fenwick-tree&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1967/problem/C&quot;&gt;CodeForces 1967C. Fenwick Tree&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Simple $O(N\log^2 N)$ from observing that length $2^i$ can be decomposed into two $2^{i - 1}$’s + realizing $\sum_{y = 1}^x \binom{y + i - 1}{i} = \binom{x + i}{i + 1}$.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1967d-long-way-to-be-non-decreasing&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1967/problem/D&quot;&gt;CodeForces 1967D. Long Way to be Non-decreasing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Consider the functional graph with edges $i \to b_i$. Since the number of operations follow monotonicity (more operations mean it is easier to get a non-decreasing sequence), so this inspires a binary search solution (so called parametric search in Korean Comp Prog community). For a fixed upperbound on operations, the greedy idea works - take the smallest possible number for the first one, then take the smallest possible number not less than the first one for the second number, etc. Since we know that if a number $\leq x$ cannot be taken for position $i$, for the rest of positions cannot take $\leq x$, so we can simply do a two-pointer, one for the array, the other for $[1, m]$. Checking distance between reachable vertices in a functional graph can be done in $O(1)$, so each iteration of this binary search takes $O(n + m)$ time complexity, overall, $O((n + m)\log m)$.&lt;/p&gt;

&lt;h3 id=&quot;naipc-2019-monotony&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/16999&quot;&gt;NAIPC 2019. Monotony&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;First, we can get the rows that are monotonic when $mask$ of columns are on in $O(r\cdot 2^c)$. Then, for each pair of rows $(i, j)$, we set a bitmask where the $k$th bit is on if $a_{i, k} &amp;gt; a_{j, k}$, let us refer this bitmask as the color of the edge $(i, j)$. Note that we only need to count monochromatic paths. Now, for each mask in $0$ to $2^c - 1$, we can compute $dp(i, x)$ which denotes the number of subsets of rows in $[1, i]$, ending at $i$ with the last color $x$. This can be done in $O(r^2)$. Thus, the overall complexity is $O(r^2\cdot 2^c)$.&lt;/p&gt;

&lt;h3 id=&quot;boj-13705-axbsinxc&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13705&quot;&gt;BOJ 13705. Ax+Bsin(x)=C&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Key observation is $A \geq B$, so the function $f(x) = Ax + B\sin(x)$ has the derivative&lt;/p&gt;

\[f&apos;(x) = A + B\cos(x) \geq A - B \geq 0\]

&lt;p&gt;so it is a non-decreasing function, which allows us to use binary search. The actual implementation requires Python Decimal due to the floating point error.&lt;/p&gt;

&lt;h3 id=&quot;boj-31417-가장-짧은-높이&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31417&quot;&gt;BOJ 31417. 가장 짧은 높이&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Noticing the height of a triangle can be computed using $h = a\sin\theta$, and we want $\theta$ to be minimized, so we only have to care about the closest angles. Thus, for each point, we set the point to be the origin, and we can sort the angle. This yields a $O(N^2\log N)$ solution.&lt;/p&gt;

&lt;h3 id=&quot;boj-17978-washer&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17978&quot;&gt;BOJ 17978. Washer&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$k = 1$ is trivial. For $k = 2$, we can think of a plane of separation between the two sets (which has to exist since otherwise we can improve it). Thus, we can iterate over all possible triplets, construct the plane, and then iterate over all the points checking if they are above or below the plane. Then, for all 8 possibilities of dividing the three points on the plane we check the value. $O(N^4)$ passes.&lt;/p&gt;

&lt;h3 id=&quot;swerc-2019e-pixels&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18297&quot;&gt;SWERC 2019E. Pixels&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The idea is simple - we have $m$ bits to represent the first row, and the final row will give us $m$ equations, so we can use Gaussian elimination to solve the system of linear equations over $\mathbb{Z}_2$. By transposing the matrix, we get a $O(nm\sqrt{nm})$ solution.&lt;/p&gt;

&lt;h3 id=&quot;open-cup-20172018---gp-of-romania-xormites&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19054&quot;&gt;Open Cup 2017/2018 - GP of Romania. Xormites&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Let $A$ be the xor sum of the entire array. If $A = 0$, it is clearly a draw, otherwise, if the first player scores $x$ points, the second player scores $x \oplus A$, so the only bit that matters is the highest bit of $A$. Hence, we can reduce the problem down to “Given an array of 0’s and 1’s, the player with odd number of 1’s wins.” Now, the key observation is that for an even length array, the first player can choose either taking all odd indexed elements or all even indexed elements, and since there are odd number of 1’s, one of the set will have odd number of 1’s, thus, the first player wins in that case. Otherwise, the first player must take 1 in the first turn for the same argument. Then, note that if the length is of the form $4k + 3$, then, the second player always wins. The moment the first player cannot copy the second player’s move, the first player loses, thus, from trial and erroring, I was able to get that the array after the first move should be of the form:&lt;/p&gt;

\[Saabb\ldots cc\overline{S}\]

&lt;p&gt;where $\overline{S}$ is the reverse of $S$. This can be found in linear time.&lt;/p&gt;

&lt;h3 id=&quot;rmi-2014-4-min-xor&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19239&quot;&gt;RMI 2014 4. min-xor&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The main idea is well-known: $a &amp;lt; b &amp;lt; c$ implies $a \oplus c &amp;gt; \min(a \oplus b, b \oplus c)$. This is obvious from considering the first bit $a$ and $c$ differ in and by pigeonhole principle, $b$ will share the same bit as one of them. Now, maintaining this can be done with two sets, but &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;multiset&lt;/code&gt; uses more memory than &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;priority_queue&lt;/code&gt;, so a multiset implementation using &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;priority_queue&lt;/code&gt; was needed to pass the very annoying memory limit.&lt;/p&gt;

&lt;h3 id=&quot;boj-31808-가우스-법칙&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31808&quot;&gt;BOJ 31808. 가우스 법칙&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;It is a simple extension to the $O(\log N)$ point in convex polygon check algorithm. For every query point, we check the triangle part it is in, and then iterate over all the neighboring triangles.&lt;/p&gt;

&lt;h3 id=&quot;ptz-winter-2015-day1-a-binomial-coefficient&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19124&quot;&gt;Ptz Winter 2015 Day1 A. Binomial Coefficient&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$\binom{n}{k} \pmod{p^e}$ problem. The idea is to compute $t$ and $m \pmod{p^e}$ for $n! = p^tm$ fast, then, rest is simple modulo inverse. Computing $t$ is trivial using Legendre’s formula. Computing $m$ requires unsigned Stirling number of the first kind -&lt;/p&gt;

\[x(x + 1)\ldots(x + n - 1) = \sum_{k = 0}^n \begin{bmatrix} n \\ k \end{bmatrix}x^k\]

&lt;p&gt;Then, let $(N!)_p$ represent the remainder of the products of numbers coprime to $p$ from $1$ to $N$ in modulo $p^e$. Let $N = up + r$. We get that&lt;/p&gt;

\[(N!)_p = {\begin{bmatrix} p \\ 1 \end{bmatrix}}^u\prod_{i = 0}^{u - 1}\left(1 + \sum_{k = 1}^{e - 1}\frac{\begin{bmatrix} p \\ k + 1 \end{bmatrix}}{\begin{bmatrix} p \\ 1 \end{bmatrix}}(ip)^k\right)\left(\sum_{k = 0}^r\begin{bmatrix} r + 1 \\ k + 1 \end{bmatrix}(up)^k\right)\]

&lt;p&gt;If we let the second term be denoted as $f_{p, e}(u)$, we can show that it is a degree $2e - 2$ polynomial using basic powers series operations. Thus, we can use Lagrange interpolation to compute $f_{p, e}(u)$. Note that we can’t simply divide by some factorials when doing Lagrange interpolation since the gcd with $p$ is not $1$, so we have to maintain the $v_p$ constantly. This allows $O(pe + e\log N)$ for each factorial computation which passes very comfortably.&lt;/p&gt;

&lt;h3 id=&quot;japan-domestic-2020-luggage&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20226&quot;&gt;Japan Domestic 2020. Luggage&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;$T = 300$ with $p &amp;lt; 10^{15}$, the constraints on the problem suggest a $O(p^{\frac{1}{3}})$-ish solution. First, we can use Pollard-Rho and Miller-Rabin algorithm to find all prime factors of $p$ in $O(p^{\frac{1}{4}}\log p)$. Then, we know that the number of divisors are roughly $O(p^{\frac{1}{3}})$, so we iterate over each $d$, and since by AM-GM, we know the sum $w + h$ is minimized when $w = h = \sqrt{\frac{p}{d}}$, so we can binary search and then bruteforce search the closest $w$, $h$, so a roughly $O(p^{\frac{1}{3}}\log p)$ solution, but I am not sure how to really prove the bruteforce part…&lt;/p&gt;

&lt;h3 id=&quot;boj-1763317646&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17646&quot;&gt;BOJ 17633/17646&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Lagrange’s Four Square theorem + some quadratic residue algorithm (Cornacchia’s algorithm). Four squares can be reduced to three squares since it must be of the form $N = 4^a(8k + 7)$, we can subtract by $(2^a)^2$. Three squares can be reduced down to two squares by randomly choosing a number $a$, and checking if $N - a^2$ can be written as a sum of two squares - the density of number that can be written as a sum of two squares is high, so the probabilistic approach works. Finally, for two squares, we use the fact that there cannot be a $p = 4k + 3$ with odd exponent, so we only have to take care of $p = 4k + 1$; we can find the quadratic residue of $x^2 \equiv -1 \pmod{p}$ from the fact that half of $Z_p$ satisfies it, so we can arbitrarily choose $x$ until it works. Then, $p \mid x^2 + 1$, so we can take the gcd of $x + i$ and $p$ which will give a Gaussian integer $a + bi$ with norm $p$, so $a^2 + b^2 = p$. Then, we can combine products of sum of two squares using&lt;/p&gt;

\[(a^2 + b^2)(c^2 + d^2) = (ac + bd)^2 + (ad - bc)^2\]

&lt;p&gt;Hence, we are done.&lt;/p&gt;

&lt;h3 id=&quot;koi-2015-중등부-금광&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/10167&quot;&gt;KOI 2015 중등부. 금광&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Essentially, for every possible starting $x$ positions, we do a sweepline to the right, maintaining a maximum subarray segment tree. $O(N^2\log N)$ complexity.&lt;/p&gt;

&lt;h3 id=&quot;open-cup-20172018---gp-of-gomel-kids-arent-alright&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19313&quot;&gt;Open Cup 2017/2018 - GP of Gomel. Kids Aren’t Alright&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;First, factor using Pollard-rho algorithm. Then, note that there are at most $16$ distinct prime factors of $m$, suggesting a $O(3^k)$ algorithm. Let $D$ be the set of divisors. For each prime, we can think about two sets $S_p\colon\{S \subseteq D \mid p\mid\gcd(S)\}$ and $T_p\colon\{S \subseteq D\mid \operatorname{lcm}(S)\mid m/p\}$. Then, we can do a PIE using these $2k$ sets, but naively doing so would be $O(4^k)$. Note that having $S_p$ or $T_p$ is essentially the same in terms of calculation, so we can reduce it down to $O(3^k)$.&lt;/p&gt;

&lt;h3 id=&quot;open-cup-20212022---gp-of-nanjing-paimons-tree&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31181&quot;&gt;Open Cup 2021/2022 - GP of Nanjing. Paimon’s Tree&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Very cool idea. The trivial dp idea is maintaining the endpoints and then hopefully shift them appropriately, but this is quite hard since when you add an edge with $(u, v)$ endpoints, it is possible to add an edge to $u$ or $v$, but not use it for the path we care. Thus, we can mark a vertex that we will use in our path from our current $(u, v)$. There will be four states - $(u, v)$ connected, one of them disconnected, and both of them disconnected, and we can easily maintain the dp transitions by precomputing the parents and the subtree size of each node with respect to all possible roots.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1975f-set&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1975/my&quot;&gt;CodeForces 1975F. Set&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The idea boils down to can we reduce the number of constraints as we fill out $S$ from the highest bit to the lowest, and the answer is in fact yes - for bit $2^i$, we can either take $i$, then, the condition $t_1$ and $t_2$ that differ by $2^i$ can be merged as $t_1 \&amp;amp; (t_2 &amp;gt;&amp;gt; 1)$, and a similar operation can be done when you don’t take the bit.&lt;/p&gt;
</description>
        <pubDate>Tue, 30 Apr 2024 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/math-cs-blog/Grind-for-NAC/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/Grind-for-NAC/</guid>
        
        <category>problem-solving</category>
        
        
      </item>
    
      <item>
        <title>April Problem-solving</title>
        <description>&lt;h3 id=&quot;joisc-20182019-cake-3&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/17677&quot;&gt;JOISC 2018/2019. Cake 3&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;First, note that for a fixed set of cakes, it is optimal to place them in an increasing order of the cost to minimize the cost penalty. Then, suppose $f(i, j)$ denote the maximum beauty of the cake given that all the cakes are chosen from $[i, j]$ and the cost incurred is $-2(C_j - C_i)$. Let $opt(i)$ be the optimum maximizing $opt(i, j)$ for $i$. It is easy to prove that $opt(i) \leq opt(i + 1)$. Thus, we can use divide and conquer optimization, and for computing the top $m$ value sum of an interval, we could use persistent segment tree or simply noting that we can use $O(optr - optl + r - l)$ operations when recursing, so we can just use a BIT with &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;lower_bound&lt;/code&gt; and move the left endpoint and right endpoint like how you would do it in Mo’s.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1921d-balanced-subsequences&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1924/problem/D&quot;&gt;CodeForces 1921D. Balanced Subsequences&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Relax the condition, and let $f(n, m, k)$ denote the number of bracket sequences such that the longest bracket subsequence is at most of length $2k$, then, the answer we are looking for is $f(n, m, k) - f(n, m, k - 1)$. We find that the recursion is&lt;/p&gt;

\[f(n, m, k) = \begin{cases}
\binom{n + m}{n} &amp;amp; \text{if $k \geq \min(n, m)$} \\
f(n, m - 1, k) + f(n - 1, m, k - 1) &amp;amp; \text{otherwise} \\
\end{cases}\]

&lt;p&gt;this leads us to guessing that $f(n, m, k) = \binom{n + m}{k}$ which can be proven from induction.&lt;/p&gt;

&lt;h3 id=&quot;boj-1144-싼-비용&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1144&quot;&gt;BOJ 1144. 싼 비용&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The main idea is noting that we can use DP on broken profile since we can incrementally add the tiles. However, the state is more involved than a simple bitmask - it needs to convey the information of which tiles are connected, so we need to use 3 bits per position, and then we can do a simple casework for the dp transition. Normalizing the bitmask, such that the first nonzero bit is assigned as 1, and so forth is necessary since it cuts down the number of states drastically, related to the Bell number (number of partition of n distinct objects). This gives an upperbound on the time complexity - $O(nm^2B_m\log B_m)$ which is sufficient.&lt;/p&gt;

&lt;h3 id=&quot;pacnw-2019h-windmill-pivot&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/18001&quot;&gt;PACNW 2019H. Windmill Pivot&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I was able to get the main idea during the virtual, though I didn’t realize the solution I have was sufficient. The key sentence in the question is that after 360 degree rotation, you are guaranteed to have reached back to your original position, which makes implementation easy. Note that there are $O(n^2)$ interesting lines arising from given $n$ points, and for each interesting lines, we can compute the next pivot in $O(n^2\log n)$ by angle sorting, so we have a functional graph with $O(n^2)$ vertices, and we only have to iterate over all the cycles which takes linear time, so in total, the time complexity is $O(n^2\log n)$.&lt;/p&gt;

&lt;h3 id=&quot;pacnw-2023g-matrix-fraud&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31512&quot;&gt;PACNW 2023G. Matrix Fraud&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We were not able to make much progress in the actual contest, though Vedant did mention he was able to solve it if $r \geq c$. Note that “column”-banded binary matrix is also “row”-banded binary matrix, so we can transpose to get $r \ge c$. Then, we simply define $f(r, c_l, c_r)$ to be the cost to modify rows $[1, r]$ such that in row $r$, we have ones in the interval $[c_l, c_r]$. The naive transition takes $O(c^2)$, but note that the area querying is a prefix rectangle, so we can make the transition $O(1)$. Hence, the DP takes $O(rc^2) = O(rc\sqrt{rc})$ which is sufficient enough to pass.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1672e-notepadexe&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1672/problem/E&quot;&gt;CodeForces 1672E. notepad.exe&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I still cannot believe I didn’t solve it back then, but I still struggled to solve this right now lol. We can find $S = \sum_{i} l_i + n - 1$ in less than $30$ queries. Then, we focus on the height $h \in [1, n]$. Clearly, we don’t care about width being larger than $\frac{S}{h}$ since we can attain $S$. Also, in the best case scenario where no space is wasted (no trailing spaces in each line), the total characters used is $S - (h - 1)$, so we have a bound on $w$ which is $[(S - (h - 1)) / h, S / h]$. Clearly, this interval always contain at most $1$ integer, so we can simply query the width in the interval for each $h \in [1, n]$ which takes exactly $n$ queries, so we are done.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1672f2-checker-for-array-shuffling&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1672/problem/F2&quot;&gt;CodeForces 1672F2. Checker for Array Shuffling&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Upsolved, had to read the editorial for the big picture. Considering the directed graph with edges from $a_i$ to $b_i$.&lt;/p&gt;

&lt;h3 id=&quot;ioi-2013-cave&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/20106&quot;&gt;IOI 2013. Cave&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;It becomes very trivial after noting that $70000 &amp;gt; N(\log N + 1)$. We iterate over the doors in an increasing order, and I toggled all $\log N$ bits, and then there are two possibilities - the mask or the negation of the mask, and we can check that manually once more. Apparently we could simply do a binary search by toggling all the switches in the range $[l, r]$.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1819c-the-fox-and-the-complete-tree-traversal&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1819/problem/C&quot;&gt;CodeForces 1819C. The Fox and the Complete Tree Traversal&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The subgraph of the form of one vertex with degree $3$, and each neighbor not being a leaf must not exist in order for the cycle to exist. If no such subgraph exists, then, the graph is of the form of a diameter and some vertices on the diameter having a leaf neighbor not on the diameter. Then, we can simply traverse from left to right, right to left jumping which is easy to prove.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1819d-misha-and-apples&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1819/problem/D&quot;&gt;CodeForces 1819D. Misha and Apples&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Just maintaining if at position $i$, if the bag can get cleared, and the maximum value achievable afterwards.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1930f-maximize-the-difference&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1930/problem/F&quot;&gt;CodeForces 1930F. Maximize the Difference&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Note that $f(b)$ can be computed by finding the maximum of $b_i \&amp;amp; ~ b_j$. Then, for adding $v$, we add all the possible submasks of $v$ into $S_1$, and $~v$ into $S_2$ via DFSing. Each submask gets visited at most once and the degree of each mask is $O(\log N)$, so the update takes $O(N\log N)$ and query takes constant time as we can simply check whenever we add a mask to a set, whether the other set already contained the mask. Thus, $O(N\log N + Q)$.&lt;/p&gt;
</description>
        <pubDate>Thu, 11 Apr 2024 00:00:00 -0700</pubDate>
        <link>http://localhost:4000/math-cs-blog/April-problem-solving/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/April-problem-solving/</guid>
        
        <category>problem-solving</category>
        
        
      </item>
    
      <item>
        <title>February Problem Solving</title>
        <description>&lt;h3 id=&quot;codeforces-1922f-replace-on-segment&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1922/problem/F&quot;&gt;CodeForces 1922F. Replace on Segment&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Note that we should never do two operations that intersect: $[l_1, r_1]$, $[l_2, r_2]$, $l_1 \le l_2 \le r_1 \le r_2$. Then, we can compute the dp recurrence for $f(l, r, k)$, $g(l, r, k)$ where $f$ is the minimum number of operation for the segment $[l, r]$ to be equal to $k$, $g$ is the minimum number of operation for the segment $[l, r]$ to be all different from $k$. This results in an $O(n^4)$ dp.&lt;/p&gt;

&lt;h3 id=&quot;cco-2018-boring-lectures&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/19634&quot;&gt;CCO 2018. Boring Lectures&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Offline deletion + Segment tree. We can use the idea used in offline dynamic connectivity, but we cannot naively do this since $N \le 10^6$, so it would result in $O(N\log N\log Q)$ which is too much, so we note that only $Q$ values are updated, so we only change those values, and leave the $N - Q$ values, compute the values for them before and do the offline dynamic connectivity style divide and conquer which results in $O(N\log N + Q\log N\log Q)$ which fits in the TL.&lt;/p&gt;

&lt;h3 id=&quot;별-보러-가자&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31227&quot;&gt;별 보러 가자&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Recall for Manhattan distance:&lt;/p&gt;

\[|x_1 - x_2| + |y_1 - y_2| = \max(x_1 + y_1 - (x_2 + y_2), -(x_1 + y_1) + (x_2 + y_2), x_1 - y_1 - (x_2 - y_2), x_2 - y_2 - (x_1 - y_1))\]

&lt;p&gt;then, we can compute $dp[N][M]$, the maximum value of sum of $R_i$ over $N$ days, $M$ observations in $O(NM)$ by realizing that suboptimal values will always be smaller due to the $\max$ operator.&lt;/p&gt;

&lt;h3 id=&quot;all-colourings&quot;&gt;&lt;a href=&quot;https://open.kattis.com/problems/allcolourings&quot;&gt;All Colourings&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Computing the values directly is hard, so we compute the values $dp[mask]$ - the number of ways satisfying at least the edges in the mask which is trivial - DSU/DFS and then simply $K^{CC}$. Then, we can do a Möbius transformation to retrieve the $dp’[mask]$ - the number of ways satisfying exactly the edges in the mask.&lt;/p&gt;

&lt;h3 id=&quot;cerc-2016-easy-equation&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13949&quot;&gt;CERC 2016. Easy Equation&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Vieta jumping + BFS.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1919f2-wine-factory-hard-version&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1919/problem/F2&quot;&gt;CodeForces 1919F2. Wine Factory (Hard Version)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Note that we can model this problem as a flow problem with each water tower $i$ has an incoming edge from the source with capacity $a_i$ and outgoing edge to a sink with capacity $b_i$, and tower $i$ has an edge to $i + 1$ with capacity $c_i$. Considering the minimum cut, we note that only $a_i$ or $b_i$ will be in the cut, and we can maintain this dynamically with a segment tree where for each node, we have a $2 \times 2$ matrix representing where the left endpoint and the right endpoint belongs.&lt;/p&gt;

&lt;h3 id=&quot;nwerc-2022-faster-than-light&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/26179&quot;&gt;NWERC 2022. Faster Than Light&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We notice that for a positive slope line, in order for the line to go through all the rectangles, it must be between the top left corner and the bottom right corner, so we can consider the convex hull of the top left corner and the convex hull of the bottom right corner and check if the two polygons intersect, which can be done in linear time using Minkowski sum. Other cases can be dealt in a similar fashion.&lt;/p&gt;

&lt;h3 id=&quot;nwerc-2022-last-guess&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/26179&quot;&gt;NWERC 2022. Last Guess&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Flow with lowerbound. The sum of greens and yellows bound the number of a specific letter, model the flow as a matching between the positions and the letters.&lt;/p&gt;

&lt;h3 id=&quot;swerc-2013-it-can-be-arranged&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/9590&quot;&gt;SWERC 2013. It Can Be Arranged&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Flow with lowerbound.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1924c-fractal-origami&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1924/problem/C&quot;&gt;CodeForces 1924C. Fractal Origami&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The formula is pretty evident, simple geometric series, and to implement the solution, we just have to implement $Z_p[\sqrt{2}]$, and this is fine since $2$ is not a quadratic residue in this $p$.&lt;/p&gt;

&lt;h3 id=&quot;nwerc-2022-alternating-algorithm&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/26174&quot;&gt;NWERC 2022. Alternating Algorithm&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Note that we can reduce the problem into the case where we only have 0’s and 1’s by letting the smaller out of the last two elements that were swapped to be denoted as $x$, then, categorize all the elements as $\le x$ or $&amp;gt; x$. After this reduction, note that the answer is lowerbounded by the number of moves for one zero to move into place + the number of zeros after it. Actually, this lowerbound is in fact the answer since if a zero gets blocked by a previous zero for couple operations, then, the value is accounted for by the earlier zeros. With this observation, we can maintain this value using a RURQ data structure, namely, a lazy segment tree, which yields a $O(n\log n)$ solution.&lt;/p&gt;

&lt;h3 id=&quot;nwerc-2022-kebab-pizza&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/26184&quot;&gt;NWERC 2022. Kebab Pizza&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;A lot of casework. The main idea is to represent the pizza slices as the edges and toppings as vertices, and if there is a vertex with three nonleaves neighbors, it is impossible, otherwise, there are two cases: one connected component is always good, if not, if there is a cycle, it is bad.&lt;/p&gt;

&lt;h3 id=&quot;boj-13727-5차원-구사과-초콜릿&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13727&quot;&gt;BOJ 13727. 5차원 구사과 초콜릿&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Bitmask DP + Berlekamp-Massey. Note that each $2 \times 2 \times 2 \times 2$ layer has to be filled up by itself or the layer that comes after it, so this gives a nice approach to compute the dp $f(l, mask, b)$ which represents $l$th layer, blocks that are on in $mask$ is filled up and we only used subset of blocks $1$, …, $b$ in this layer. This gives a $O(2^{16}2^5L)$ solution for the first $L$ layers which is not enough, so we need to use Berlekamp-Massey after computing the first $300$ values or so, then, we can find the linear recurrence.&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Feb 2024 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/math-cs-blog/February-problem-solving/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/February-problem-solving/</guid>
        
        <category>problem-solving</category>
        
        
      </item>
    
      <item>
        <title>January Problem Solving</title>
        <description>&lt;h3 id=&quot;spotify-challenge-2010-apparatus&quot;&gt;&lt;a href=&quot;https://open.kattis.com/problems/apparatus&quot;&gt;Spotify Challenge 2010. Apparatus&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The problem is asking the number of bijective functions $f \colon [n] \to [n]$ such that for the given input $(S_i, T_i)$, $f(S_i) = T_i$. Note that if we can decompose the domain $[n]$ into disjoint sets that are of the form $\bigcap_{i \in I} S_i$, we can simply compute the product of the number of permutations in each disjoint set. We can do this by maintaining the disjoint sets induced by $S_1, \dots, S_{i - 1}$ and inserting a new set $S_i$ can be done in $O(n)$, so the time complexity is $O(n^2)$.&lt;/p&gt;

&lt;h3 id=&quot;bapc-2017-ghostbusters&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/14994&quot;&gt;BAPC 2017. Ghostbusters&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We can consider the bipartite graph $G$ with rows and columns being the vertices. We find the connected components of $G$, and for each connected component, we compute the maximum spanning tree since if there is a cycle, we can always remove one of the edges to have a higher probability, and we are to find&lt;/p&gt;

\[\operatorname{argmax}_{T \colon spanning tree} \prod_{e_i \in T} p_i = \operatorname{argmax}_{T \colon spanning tree} \sum_{e_i \in T} \ln p_i\]

&lt;p&gt;since $\ln$ is monotonic. The time complexity should be $O(E\log E) = O(nm\log nm)$.&lt;/p&gt;

&lt;h3 id=&quot;codeforces-1553g&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1553/problem/G&quot;&gt;CodeForces 1553G&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Notice that the answer will be at most $2$ since $2 \mid a_i(a_i + 1)$ for any $a_i$, so we can always create two nodes to satisfy the condition. 
Also, we can compute the connected components by storing $i$ in each prime divisor of $a_i$, and for each prime number, we connect all the vertices stored there. This covers when the answer is zero. For the one case, for each $i$, we compute the prime divisors of $a_i(a_i + 1)$ and which connected components it will connect when added: let $S_i$ denote the ids of the connected components. $|S_i| \leq 8$, so we can precompute all the connected component pairs that can be connected with one additional vertex in $O(\binom{8}{2}n)$. 
The overall time complexity will be $O(A + n\log A)$, where $A$ is the maximum possible value of $a_i$.&lt;/p&gt;

&lt;h3 id=&quot;codesprint-la-2023-food-mixing&quot;&gt;&lt;a href=&quot;https://open.kattis.com/contests/j4ce6r/problems/foodmixing?tab=metadata&quot;&gt;CodeSprint LA 2023. Food Mixing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The problem statement can be reduced down to:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Given a set $S$ of 2D points $P_1, \dots, P_n$, check whether $(x, y) \in \operatorname{conv}(S)$.&lt;/li&gt;
  &lt;li&gt;If so, output a valid convex combination that results in $(x, y)$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This can be done by computing the convex hull of $S$, and check whether $(x, y)$ is in the convex polygon, and if so, split the convex polygon into triangles of the form $Q_1Q_iQ_{i + 1}$, where we can retrieve the coefficients using line intersection. There are some edge cases, such as when the convex polygon is degenerate, but that’s Geo for ya.&lt;/p&gt;

&lt;h3 id=&quot;boj-31027-물고기-게임&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31027&quot;&gt;BOJ 31027. 물고기 게임&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Simple casework.&lt;/p&gt;

&lt;h3 id=&quot;boj-31030-순열과-수열&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31030&quot;&gt;BOJ 31030. 순열과 수열&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We note that for disjoint cycles of $A$, they do not affect the corresponding $B$ values, so we focus on individual cycles. Consider the cycle $i, A_i, A_{A_i}, \dots$. If we set $B_i = k$, $B_{A_i} = A_k$, $B_{A_{A_i}} = A_{A_k}, \dots$, and the only condition that needs to be satisfied is the length of the cycle $k$ is in must divide the cycle length of $i$. For each cycle, we can do this in $O(NC)$, so the solution runs in $O(\sum NC) = O(N^2)$.&lt;/p&gt;

&lt;h3 id=&quot;dwango-programming-contest-6th-cookie-distribution&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/dwacon6th-prelims/tasks/dwacon6th_prelims_c&quot;&gt;Dwango Programming Contest 6th. Cookie Distribution&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Application of the so-called “product trick”. The product can be viewed as the number of ways to color one cookie red for each child. Let $dp[i][j]$ be the number of ways such that in the first $i$ days, $j$ children get red cookies. The dp recurrence is&lt;/p&gt;

\[dp[i][j] = \sum_{m = 0}^{\min(a_i, j)} dp[i - 1][j - m]\binom{n - j + m}{m}\binom{n - m}{a_i - m}\]

&lt;p&gt;and the answer is $dp[k][n]$. This can be computed in $O(kn^2)$&lt;/p&gt;

&lt;h3 id=&quot;abc-231g-balls-in-boxes&quot;&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc231/tasks/abc231_g&quot;&gt;ABC 231G. Balls in Boxes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Another application of “product trick”. This time, we start with some number of balls, so we first compute the number of ways to color $j$ balls when considering the first $i$ boxes: $dp[i][j]$.&lt;/p&gt;

\[dp[i][j] = dp[i - 1][j] + a[i]dp[i - 1][j - 1]\]

&lt;p&gt;and then for each $0 \leq m \leq n$, the value $dp[n][m]$ will contribute&lt;/p&gt;

\[\frac{1}{n^m}dp[n][m]\binom{k}{n - m}(n - m)!n^{k - n + m}\]

&lt;h3 id=&quot;codeforces-1919f1-wine-factory-easy-version&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1919/problem/F1&quot;&gt;CodeForces 1919F1. Wine Factory (Easy Version)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We can model each water tower as a ReLU function: $f_i(x) = \max(x + a_i - b_i, 0)$, and ReLU functions of the form $g(x) = \max(x + a, 0) + b$ is indeed a monoid (by introducing an artificial identity function), so we can use a segment tree to compute the remaining water which is $seg[0…n - 1](0)$.&lt;/p&gt;

&lt;h3 id=&quot;swerc-2015-game-of-cards&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/11683&quot;&gt;SWERC 2015. Game of Cards&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Simple Sprague-Grundy theorem application&lt;/p&gt;

&lt;h3 id=&quot;swerc-2017-cordan-bleu&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/15416&quot;&gt;SWERC 2017. Cordan Bleu&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We note that the distance from the restaurant to the wine merchants is included regardless. To match a wine cellar with a courier, it is a weighted bipartite matching which can be solved using MCMF or Hungarian algorithm. The time limit is quite tight.&lt;/p&gt;

&lt;h3 id=&quot;swerc-2016-passwords&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/13961&quot;&gt;SWERC 2016. Passwords&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We make an AC-automaton with the blacklisted words, and then propagate the blacklist information through suffix links/children. Then, we can do a dynamic programming with the state being $(len, pos, has\_low, has\_up, has\_num)$.&lt;/p&gt;

&lt;h3 id=&quot;boj-31032-트리의-개수&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/31032&quot;&gt;BOJ 31032. 트리의 개수&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Using indicator variables, we can write the desired sum as the following:&lt;/p&gt;

\[\sum_{j = 1}^{K}g_j(T) = \sum_{j = 1}^{K}\sum_{T&apos;\subseteq T}1 + \sum_{e \in E&apos;}[A_u \leq j \lor A_v \leq j] - \sum_{v \in V&apos;}[A_v \leq j]\]

&lt;p&gt;All three terms can be computed by first rearranging and then using tree dp, where $dp[u]$ is the number of connected subgraphs that has $u$ as the closest vertex to the root, and $revdp[u]$ is the number of connected subgraphs that includes $par[u]$, and does not include $u$. The recurrences are&lt;/p&gt;

\[dp[u] = \prod_{i = 1}^k (1 + dp[c_i])\]

&lt;p&gt;and&lt;/p&gt;

\[revdp[u] = (revdp[par[u]] + 1) \frac{dp[par[u]]}{1 + dp[u]}\]

&lt;p&gt;The time complexity is $O(n)$.&lt;/p&gt;

&lt;h3 id=&quot;boj-30989-다항함수의-미분과-나머지&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/30989&quot;&gt;BOJ 30989. 다항함수의 미분과 나머지&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Essentially, the condition with the kth derivative is:&lt;/p&gt;

\[f^{(k)}(x) = \sum_{i = k}^n (i)_kc_ix^{i - k} = \sum_{j = 0}^d r_jt^j\]

&lt;p&gt;and $(i)_k \pmod{m}$ can be computed using a segment tree or factorizing $m$ into its prime factors and doing a sliding window, maintaining the power of $p$ and the product that is coprime with $p$. Then, $(i)_kc_i \equiv s_j \pmod{m}$, so we can solve this by extended euclidean algorithm, and find the range of $c_i$. There is a lot of edge cases that we need to consider, which is left as an exercise for the reader.&lt;/p&gt;

&lt;h3 id=&quot;usaco-jan20-platinum-minimizing-haybales&quot;&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/24485&quot;&gt;USACO Jan20 Platinum. Minimizing Haybales&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The main observation is that for each $1 \leq i \leq N$, 
the cardinality of the set $S_i := \{j \in [i - 1] \colon |h_j - h_i| &amp;gt; K\}$ is invariant under the given operation, so the idea for the solution is to take the smallest $h_i$ that satisfies $|S_i| = 0$, and remove $h_i$ from the remaining $S_j$’s. This can be done via square root decomposition or segment tree.&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Jan 2024 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/math-cs-blog/January-problem-solving/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/January-problem-solving/</guid>
        
        <category>problem-solving</category>
        
        
      </item>
    
      <item>
        <title>CodeForces Pinely Round 3</title>
        <description>&lt;p&gt;I am very happy with my performance in the round despite not participating for nearly 6 months. Back to IM!&lt;/p&gt;

&lt;h2 id=&quot;before-contest&quot;&gt;Before Contest&lt;/h2&gt;

&lt;p&gt;I warmed up by solving &lt;a href=&quot;https://codeforces.com/contest/1863&quot;&gt;Pinely Round 2&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&quot;a&quot;&gt;A&lt;/h3&gt;

&lt;p&gt;We compute the optimal scenario and the pessimal scenario: 
Optimal is assuming that when every time someone comes online, the person has yet to read the post. Pessimal is assuming that every time someone comes online, if it is possible, we assume the person has already read the post.&lt;/p&gt;

&lt;p&gt;This should yield a simple $O(n)$ solution.&lt;/p&gt;

&lt;h3 id=&quot;b&quot;&gt;B&lt;/h3&gt;

&lt;p&gt;We notice that when we choose $x$ and then $y &amp;gt; x$, the part where it is $&amp;lt; x$ does not change at all in the second operation. This observation motivates a greedy solution, where if $i…j$ is already in the right order as a subsequence of the permutation, we we should do an operation with $j$.&lt;/p&gt;

&lt;p&gt;Storing the indices of $1$ to $n$ and scanning in that order should lead to an $O(n)$ solution.&lt;/p&gt;

&lt;h3 id=&quot;c&quot;&gt;C&lt;/h3&gt;

&lt;p&gt;The crucial observation is that we could think of the operation as rotating a $n + 1$ length array, where the initial array is $a_1$, $\dots$, $a_n$, $a_{n + 1}$, and&lt;/p&gt;

\[a_{n + 1} = \frac{n(n + 1)}{2} - \sum_{i = 1}^n a_i\]

&lt;p&gt;Then, we only care about $k \pmod{n + 1}$ number of operations, which can be simulated in $O(k)$ using a deque or use the std::rotate() function.&lt;/p&gt;

&lt;h3 id=&quot;d&quot;&gt;D&lt;/h3&gt;

&lt;p&gt;Dominoes that are placed horizontally do not affect the row count, and vice versa, so we can color the vertical dominoes by scanning row by row, making sure that there are only even number of vertical dominoes occupying each row, and similarly with the columns.&lt;/p&gt;

&lt;p&gt;The time complexity is $O(nm)$.&lt;/p&gt;

&lt;h3 id=&quot;e&quot;&gt;E&lt;/h3&gt;

&lt;p&gt;If we know which hour to start, we can greedily complete the quests, completing whichever is completable, but the number of hours is $k \leq 10^9$, so we have to find a smarter approach. We use dynamic programming: $dp[u]$ represents the fastest time that the quests dependent on quest $u$ can be completed, and it satisfies the following recursion:&lt;/p&gt;

\[dp[u] = \max_{v \in N(u)} 
\begin{cases}
    dp[v] &amp;amp; \text{if $h[u] \leq h[v]$} \\
    dp[v] + (1, 0) &amp;amp; \text{if $h[u] &amp;gt; h[v]$} \\
\end{cases}\]

&lt;p&gt;and then, we add a dummy node that represents the super source with edges from the super source to the sources in the original graph. Using storing a suffix maximum, we can iterate all possible starting time, and choose whichever takes the shortest amount of time.&lt;/p&gt;

&lt;p&gt;The time complexity should be $O(n + m)$.&lt;/p&gt;

&lt;h3 id=&quot;f&quot;&gt;F&lt;/h3&gt;

&lt;p&gt;Let $S = \oplus_{i = L}^R a_i$, $x = \oplus_{i = L}^k a_i$, $y = \oplus_{i = k + 1}^R a_i$, then, $S = x \oplus y$, and there are two cases:&lt;/p&gt;

&lt;p&gt;i) $S = 0$&lt;/p&gt;

&lt;p&gt;Then, for any $L &amp;lt; k &amp;lt; R$, we can attain $[L, k]$ and $[k + 1, R]$.&lt;/p&gt;

&lt;p&gt;ii) $S &amp;gt; 0$&lt;/p&gt;

&lt;p&gt;Then, whichever of $x$ and $y$ that has the MSB of $S$ can be attained.&lt;/p&gt;

&lt;p&gt;We maintain an array $msbs[i]$ which stores the MSB of a “good” array, and another array $is\_zero[i]$ which is true if there is a “good” array with xor sum zero.&lt;/p&gt;

&lt;p&gt;The time complexity should be $O(n^2)$.&lt;/p&gt;

&lt;h2 id=&quot;actual-contest&quot;&gt;&lt;a href=&quot;https://codeforces.com/contest/1909&quot;&gt;Actual Contest&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;a-1&quot;&gt;A&lt;/h3&gt;

&lt;p&gt;The only case that is not achievable is when there exists a point with a positive $x$-value, a point with a positive $y$-value, a point with a negative $x$-value, and a point with a negative $y$-value, where each point does not necessarily have to be different.&lt;/p&gt;

&lt;p&gt;This can be checked in $O(n)$.&lt;/p&gt;

&lt;h3 id=&quot;b-1&quot;&gt;B&lt;/h3&gt;

&lt;p&gt;Considering the binary representation. Since each $a_i$ is distinct, there exists a position $j$ where not all $a_i$ shares the same value for that position, and we can find the first position where they differ. Then, $2^j$ is the answer.&lt;/p&gt;

&lt;p&gt;The time complexity is $O(n\log\text{MAX})$ if done naively, otherwise, $O(n + \log\text{MAX})$ is possible.&lt;/p&gt;

&lt;h3 id=&quot;c-1&quot;&gt;C&lt;/h3&gt;

&lt;p&gt;Note that if there exists a pair of intervals intersecting, it is always better to make them nested, and there exists only one configuration that satisfies it, which can be found by sorting the $l$ values and the $r$ values.&lt;/p&gt;

&lt;p&gt;The time complexity is $O(n\log n)$&lt;/p&gt;

&lt;h3 id=&quot;d-1&quot;&gt;D&lt;/h3&gt;

&lt;p&gt;Each $a_i$ is independent of each other, so we should focus on a single one. For $a_i$, after performing $m$ of the operation, it is possible to make $m + 1$ copies of $\frac{a_i + km}{m + 1} = k + \frac{a_i - k}{m + 1}$. So we need to make the value of $\frac{a_i - k}{m + 1}$ the same for every $i$. Let $g = \gcd_{i = 1}^n (a_i - k)$, then, $m_i = \frac{a_i - k}{g} - 1$.&lt;/p&gt;

&lt;p&gt;The time complexity is $O(n + \log\text{MAX})$.&lt;/p&gt;

&lt;h3 id=&quot;e-1&quot;&gt;E&lt;/h3&gt;

&lt;p&gt;If we simply turn on all the switches, only the perfect squares will remain, so for $n$ that satisfies $\lfloor\sqrt{n}\rfloor \leq \lfloor\frac{n}{5}\rfloor$, which holds true for all $n \geq 20$, we can always satisfy the condition. Now, for $n \leq 19$, we focus on the vectors $v_i \in \mathbb{Z}_2^n$, representing the lights that are turned on by switch $i$, and $v_1$, $\dots$, $v_n$ is the basis, so there are $\binom{n}{1} + \binom{n}{2} + \binom{n}{3} = O(n^3)$ valid combinations of switches.&lt;/p&gt;

&lt;p&gt;Caching the valid combination of switches, we can achieve $O(Tn^4)$.&lt;/p&gt;

&lt;h3 id=&quot;f1--f2&quot;&gt;F1 &amp;amp; F2&lt;/h3&gt;

&lt;p&gt;Let $dp[i]$ be the number of valid placements of $1$ to $i$ that satisfies the restrictions $a_1$, $\dots$, $a_i$, and let $c = i - a_i$. Suppose the next position that isn’t $-1$ is $j &amp;gt; i$. Then, the recurrence is&lt;/p&gt;

\[dp[j] = dp[i]\sum_{k = 0}^{a_j - a_i}\binom{j - i}{k}\binom{c}{a_j - a_i - k}\binom{j - i}{a_j - a_i - k}(a_i - a_j - k)!\binom{j - a_j + k}{k}k!\]

&lt;p&gt;Since $a_i$ must be an increasing sequence (excluding $-1$s) for the restriction to have a valid permutation, the time complexity is $O(n)$.&lt;/p&gt;

&lt;h2 id=&quot;afterthought&quot;&gt;Afterthought&lt;/h2&gt;

&lt;p&gt;The quality of each problem was amazing. I hope the following Div 1+2 rounds also have this high-quality problems.&lt;/p&gt;
</description>
        <pubDate>Sat, 23 Dec 2023 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/math-cs-blog/CodeForces-Pinely-Round-3/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/CodeForces-Pinely-Round-3/</guid>
        
        <category>problem-solving</category>
        
        <category>contest</category>
        
        
      </item>
    
      <item>
        <title>February Problem-solving</title>
        <description>&lt;p&gt;&lt;a href=&quot;https://cses.fi/problemset/task/2181&quot;&gt;CSES Counting Tiles&lt;/a&gt;&lt;/p&gt;

&lt;details style=&quot;margin-bottom: 5%&quot;&gt;

  &lt;summary&gt;Solution&lt;/summary&gt;

  &lt;p&gt;This technique is called “DP on broken profile”. Interesting to note that
problem K from ICPC PACNW Regionals from today can also be solved using this technique
(Thankfully, in the contest, I was able to solve it quite straightforwardly). This problem is easier as we only have to
maintain a bitmask of which tiles are open. This allows a
$O(nm2^n)$ solution. The dp states are $dp[i][j][mask]$, where
$(i, j)$ is the corner, but since $dp[i][j]$ relies solely on
$dp[i][j - 1]$, we can drop the first two dimensions leading
to a $O(2^n)$ memory.&lt;/p&gt;

&lt;/details&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/662/problem/C&quot;&gt;CodeForces 662C&lt;/a&gt;&lt;/p&gt;

&lt;details style=&quot;margin-bottom: 5%&quot;&gt;

  &lt;summary&gt;Solution&lt;/summary&gt;

  &lt;p&gt;Bitmask DP + Finding the linear recurrence. We can first think of
each column as a bitmask of length $n$, labeling them $col_1$,
$col_2$, $\dots$, $col_m$. Then, the rows that are being inversed
could be also represented as a bitmask of length $n$, denoted as
$mask$. Then, we are calculating the $mask$ that minimizes the sum&lt;/p&gt;

\[\sum_{i = 1}^{m} \min(pc(mask \oplus col_i), n - pc(mask \oplus col_i))\]

  &lt;p&gt;where $pc$ is the popcount function. This takes $O(2^n m)$, which is very slow. In order to improve this, we define $dp[k][mask]$ to be the number of $col_i$ such that $pc(col_i, mask) = k$. We can easily calculate $dp[0][mask]$ in $O(m)$ as $mask$ has to equal $col_i$. Suppose $k &amp;gt; 0$, and $pc(col_i, mask) = k$. We can consider a position $p$, such that $col_i$ and $mask$ differs in. Then, there would be $dp[k - 1][mask \oplus 2^p]$ possible columns, but it could be possible that $col_i$ and $mask \oplus 2^p$ differs in position $p$ again, so we have to subtract $dp[k - 2][mask]$, and repeating this process, if $pmask$ denotes $mask \oplus 2^p$, we get&lt;/p&gt;

\[dp[k - 1][pmask] - dp[k - 2][mask] + dp[k - 3][pmask] - \dots\]

  &lt;p&gt;If we sum for all $0 \leq p \leq n - 1$, then we would count each $col_i$ $k$ times, so $k \cdot dp[k][mask]$. Hence,&lt;/p&gt;

\[dp[k][mask] = \frac{1}{k} \sum_{p = 0}^{n - 1} \sum_{f = 1}^{k} (-1)^{f - 1} dp[k - f][mask \oplus (2^p \cdot (f \bmod 2))]\]

  &lt;p&gt;There are $n \cdot 2^n$ states and $n^2$ per transition, yielding a $O(n^3 \cdot 2^n)$ which is still too slow. Note that&lt;/p&gt;

\[\sum_{p = 0}^{n - 1} \sum_{f = 3}^{k} (-1)^{f - 1} dp[k - f][mask \oplus (2^p \cdot (f \bmod 2))]
= (k - 2)dp[k - 2][mask]\]

  &lt;p&gt;so&lt;/p&gt;

\[dp[k][mask] = \frac{1}{k} \left((k - 2 - n)dp[k - 2][mask] +
\sum_{p = 0}^{n - 1} dp[k - 1][mask \oplus 2^p]\right)\]

  &lt;p&gt;yielding a $O(n)$ transition, hence, a $O(n^2 \cdot 2^n)$ solution.&lt;/p&gt;

&lt;/details&gt;

&lt;p&gt;&lt;a href=&quot;https://oj.uz/problem/view/CEOI16_kangaroo&quot;&gt;CEOI 2016 Kangaroo&lt;/a&gt;&lt;/p&gt;

&lt;details style=&quot;margin-bottom: 5%&quot;&gt;

  &lt;summary&gt;Solution&lt;/summary&gt;

  &lt;p&gt;Connected component DP. Note that the problem can be restated as counting the number of permutation $p_1$, $\dots$, $p_n$, such that $p_1 = cs$, $p_n = cf$, and for all $2 \leq i \leq n - 1$, either $p_{i - 1} &amp;lt; p_i &amp;gt; p_{i + 1}$ or $p_{i - 1} &amp;gt; p_i &amp;lt; p_{i + 1}$ holds. Then, we can proceed with the typical dp states $dp[i][j]$ which represents the number of correct permutations, partially filled with $1$ to $i$, that has $j$ connected components. We note that because we insert the elements in increasing order, we can only either merge two connected components or add an independent component. Obviously, the corner cases are when $i = cs$ or $i = cf$, but they are trivial. Thus, we get a $O(n^2)$ solution with $O(n)$ memory usage.&lt;/p&gt;

&lt;/details&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1634/F&quot;&gt;CodeForces 1634F&lt;/a&gt;&lt;/p&gt;

&lt;details style=&quot;margin-bottom: 5%&quot;&gt;

  &lt;summary&gt;Solution&lt;/summary&gt;

  &lt;p&gt;Modified prefix sum. Consider $C_i = A_i - B_i$, and $D_1 = C_1$, $D_2 = C_2 - C_1$, $D_i =
C_i - C_{i - 1} - C_{i - 2}$. Note that $A = B$ if and only if $D_i = 0$ for all $i$.
Also, for each query $[l, r]$, only $D_l \mathrel{+}= 1$, $D_{r + 1} \mathrel{-}= F_{r - l + 2}$, $D_{r + 2} \mathrel{-}= F_{r - l + 1}$.
So we can easily update $D$ by precomputing the Fibonacci numbers. Hence, we get a
$O(N + Q)$ solution.&lt;/p&gt;

&lt;/details&gt;
</description>
        <pubDate>Sat, 25 Feb 2023 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/math-cs-blog/February-problems/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/February-problems/</guid>
        
        <category>problem-solving</category>
        
        
      </item>
    
      <item>
        <title>Aho-Corasick and Applications</title>
        <description>&lt;p&gt;&lt;em&gt;Prerequisites:&lt;/em&gt; Aho-Corasick&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Problems&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://codeforces.com/problemset/problem/1400/F&quot;&gt;CodeForces Edu Round 94 F&lt;/a&gt;&lt;/p&gt;

&lt;details&gt;

  &lt;summary&gt; Solution &lt;/summary&gt;

  &lt;p&gt;Bruteforce + Aho-Corasick + DP&lt;/p&gt;

  &lt;p&gt;Note that the maximum number of x-prime strings for $x \leq 20$ is $2399$ and the size of the
automaton created by those strings is at most $5000$. If we let $m$ to be the size of the AC
Automaton, we can get a simple $\mathcal{O}(|S|m)$ DP where a dp state $dp_{i, j}$ stores the
minimum number of characters removed in the prefix $S[1\dots i]$, such that we have the resulting
string ending up at vertex $j$ in the AC Automaton.&lt;/p&gt;

&lt;/details&gt;
</description>
        <pubDate>Sun, 15 Jan 2023 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/math-cs-blog/Aho-Corasick-and-applications/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/Aho-Corasick-and-applications/</guid>
        
        <category>string</category>
        
        
      </item>
    
      <item>
        <title>First Post</title>
        <description>&lt;p&gt;Hello! I am Youngmin Park, a first-year math &amp;amp; compsci major at UC Berkeley. I decided to make a blog to become
a more organized person as my notes have been everywhere, very disorganized. Hopefully, this would change.
Anyways, I will probably write things related to my studies, and competitive programming stuff.&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Jan 2023 00:00:00 -0800</pubDate>
        <link>http://localhost:4000/math-cs-blog/first-post/</link>
        <guid isPermaLink="true">http://localhost:4000/math-cs-blog/first-post/</guid>
        
        <category>intro</category>
        
        
      </item>
    
  </channel>
</rss>
